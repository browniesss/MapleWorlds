@Component
script pvpMatcherMakerComponent extends Component

	property table targetUserList = {}

	@Sync
	property integer selected = 0

	@ExecSpace("Server")
	method void RefreshListCall()
		_ProtocolService:CommonCall(senderUserId)

		local user = _UserService:GetUserEntityByUserId(senderUserId)

		local score = user.pvpRankingComponent.score

		local tierPool = _pvpRankingService:GetUserListByTier(score)

		-- 자기 자신 제거
		local filteredPool = {}
		for _, u in ipairs(tierPool) do
			if u.uid ~= senderUserId then
				table.insert(filteredPool, u)
			end
		end
		tierPool = filteredPool

		-- 티어 풀이 4명 미만일 때 더미 덱 생성
		if #tierPool < 4 then
			local tierName = _pvpDummyDeckService:GetTierNameFromScore(score)
			local dummyScore = math.max(0, score - 10)
			local usedNicknames = {}
			for i = #tierPool + 1, 4 do
				local nickname = _pvpDummyDeckService:GetRandomNicknameByTier(tierName)
				local attempts = 0
				while usedNicknames[nickname] and attempts < 10 do
					nickname = _pvpDummyDeckService:GetRandomNicknameByTier(tierName)
					attempts = attempts + 1
				end
				usedNicknames[nickname] = true
				local dummyUser = {
					uid = "dummy_" .. i,
					score = dummyScore + math.random(0, 20),
					rank = 0,
					nickname = nickname,
					isDummy = true,
					defense_deck = {},
					unitInfo = {},
					tierName = tierName
				}
				table.insert(tierPool, dummyUser)
			end
		end

		-- 실제 유저에 닉네임 설정
		for _, u in ipairs(tierPool) do
			if not (u.isDummy or false) then
				local nickname = _pvpRankingService:GetNickname(u.uid)
				if nickname ~= nil then
					u.nickname = nickname
				end
			end
		end

		local newList = {}

		math.randomseed(os.time())
		for i = #tierPool, 2, -1 do
			local j = math.random(1, i)
			tierPool[i], tierPool[j] = tierPool[j], tierPool[i]
		end

		-- 최대 4명 선택
		for i = 1, math.min(4, #tierPool) do
			newList[#newList + 1] = tierPool[i]
		end

		-- 덱 데이터 프리페치 (REFRESH 시점에 캐싱)
		for i = 1, #newList do
			local target = newList[i]
			if not (target.isDummy or false) then
				local targetData = _pvpUserService:GetUserData(target.uid)
				if targetData.code == 0 then
					target.cachedDeck = targetData.defense_deck or {}
					target.cachedSynergy = targetData.defense_synergy or {}
				else
					target.cachedDeck = {}
					target.cachedSynergy = {}
				end
				target.cachedUnitInfo = self:FetchUnitInfo(target.uid, target.cachedDeck)
			else
				local dummyDeck = _pvpDummyDeckService:GetDummyDeckByTier(target.tierName or "bronze")
				target.cachedDeck = dummyDeck.defense_deck
				target.cachedUnitInfo = dummyDeck.unitInfo
				target.cachedSynergy = dummyDeck.defense_synergy or {}
			end
		end

		self.targetUserList = newList
		self:RefeshListBack(newList)
	end

	@ExecSpace("Client")
	method void RefeshListBack(table list)
		self.targetUserList = list

		local pvpLobbyUI = _EntityService:GetEntityByPath("/ui/PvPLobbyUI")
		if pvpLobbyUI ~= nil and pvpLobbyUI.PvPLobbyUI ~= nil then
			pvpLobbyUI.PvPLobbyUI:UpdateSlots(list)
		end
	end

	@ExecSpace("ServerOnly")
	method table FetchUnitInfo(string uid, table defenseDeck)
		local opponentDS = _DataStorageService:GetUserDataStorage(uid)
		local unitKeys = {}
		for _, unitId in ipairs(defenseDeck) do
			if unitId ~= nil and unitId ~= "" then
				unitKeys[#unitKeys + 1] = "USER_" .. unitId
			end
		end

		local unitDataMap = {}
		if #unitKeys > 0 then
			local errCode, pages = opponentDS:BatchGetAndWait(unitKeys)
			if errCode == 0 then
				while true do
					local datas = pages:GetCurrentPageDatas()
					for _, data in pairs(datas) do
						if data.Value ~= nil then
							local model = UserUnitModel()
							if model:DECODE(data.Value) then
								unitDataMap[model.id] = model
							end
						end
					end
					if pages.IsLastPage then
						break
					end
					pages:MoveToNextPageAndWait()
				end
			end
		end

		local unitInfo = {}
		for _, unitId in ipairs(defenseDeck) do
			if unitId ~= nil and unitId ~= "" then
				local unitData = _UnitService:GetUnitByIDFromServer(unitId)
				if unitData ~= nil then
					local level = 1
					local limitBreak = 1
					local userUnit = unitDataMap[unitId]
					if userUnit ~= nil then
						level = userUnit.level
						limitBreak = userUnit.limitBreak
					end
					unitInfo[unitId] = {
						id = unitId,
						level = level,
						limitBreak = limitBreak,
						cost = unitData["cost"] or unitData["summonCost"] or 0
					}
				end
			end
		end

		return unitInfo
	end

	@ExecSpace("Server")
	method void FetchOpponentDeckCall(integer index)
		_ProtocolService:CommonCall(senderUserId)

		if index < 1 or index > #self.targetUserList then
			return
		end

		local target = self.targetUserList[index]
		if target == nil then
			return
		end

		-- 캐시된 덱 데이터 사용
		local deckData = {
			defense_deck = target.cachedDeck or {},
			unitInfo = target.cachedUnitInfo or {},
			nickname = target.nickname or "",
			defense_synergy = target.cachedSynergy or {}
		}

		self:FetchOpponentDeckBack(deckData)
	end

	@ExecSpace("Client")
	method void FetchOpponentDeckBack(table deckData)
		local pvpLobbyUI = _EntityService:GetEntityByPath("/ui/PvPLobbyUI")
		if pvpLobbyUI ~= nil and pvpLobbyUI.PvPLobbyUI ~= nil then
			pvpLobbyUI.PvPLobbyUI:ShowOpponentDeck(deckData)
		end
	end

	@ExecSpace("Server")
	method void StartMatchCall(integer index)
		_ProtocolService:CommonCall(senderUserId)

		if index < 1 or index > #self.targetUserList then
			return
		end

		local target = self.targetUserList[index]
		if target == nil then
			return
		end

		-- 캐시된 덱 데이터 사용
		local matchData = {
			uid = target.uid,
			defense_deck = target.cachedDeck or {},
			unitInfo = target.cachedUnitInfo or {},
			nickname = target.nickname or "",
			isDummy = target.isDummy or false
		}

		-- pvpCombatComponent에 매치 정보 설정
		local pvpManager = _EntityService:GetEntityByPath(_pvpService.PVP_STAGE_PATH .. "/PvPManager")
		local pvpCombat = pvpManager ~= nil and pvpManager.pvpCombatComponent or nil
		if pvpCombat ~= nil then
			pvpCombat:SetMatchInfo(matchData)
		end

		-- 게임 모드 설정
		_GameManager.currentGameMode = _eGameMode.PvP

		-- 맵 텔레포트
		_TeleportService:TeleportToMapPosition(
			_UserService:GetUserEntityByUserId(senderUserId),
			Vector3.zero,
			"StagePvP"
		)

		-- 게임 시작
		if pvpCombat ~= nil then
			pvpCombat:GameStartCall(senderUserId)
		end
	end

end
