@Component
script pvpUserComponent extends Component

	property integer play_coin = 5

	property table offense_deck = {}

	property table defense_deck = {}

	property table offense_synergy = {}

	property table defense_synergy = {}

	property integer next_play_coin = 0

	@ExecSpace("ServerOnly")
	method void OnUpdate(number delta)
		local nowTs = DateTime.UtcNow.Elapsed
		if self.next_play_coin > nowTs then
			return
		end

		if self.play_coin >= 5 then
			return
		end

		local addCoin = math.floor((nowTs - self.next_play_coin) / _pvpUserService.PLAY_COIN_UPDATE) + 1

		self.play_coin += addCoin
		if self.play_coin > _pvpUserService.MAX_PLAY_COIN then
			self.play_coin = _pvpUserService.MAX_PLAY_COIN
		end

		self.next_play_coin = nowTs + _pvpUserService.PLAY_COIN_UPDATE

		self:UserCoinBack(self.play_coin)
		self:UpdateCoinNextTs(self.next_play_coin)
	end

	@ExecSpace("Server")
	method void GetUserDataCall()
		_ProtocolService:CommonCall(senderUserId)

		local data = _pvpUserService:GetUserData(senderUserId)
		if not (data.code == 0) then
			log_error("fail at _pvpUserService:GetUserData " .. senderUserId)
			return
		end

		self.play_coin = data.play_coin
		self.next_play_coin = data.next_play_coin
		self.offense_deck = data.offense_deck
		self.defense_deck = data.defense_deck
		self.offense_synergy = data.offense_synergy
		self.defense_synergy = data.defense_synergy

		self:GetUserDataBack(data)
	end

	@ExecSpace("Client")
	method void GetUserDataBack(table data)
		self.play_coin = data.play_coin
		self.next_play_coin = data.next_play_coin
		self.offense_deck = data.offense_deck
		self.defense_deck = data.defense_deck
		self.offense_synergy = data.offense_synergy
		self.defense_synergy = data.defense_synergy
	end

	@ExecSpace("Client")
	method void UserCoinBack(integer coin)
		self.play_coin = coin
	end

	@ExecSpace("Client")
	method void UpdateCoinNextTs(integer ts)
		self.next_play_coin = ts
	end

	@ExecSpace("ServerOnly")
	method table ComputeSynergy(table deck)
		local syncCols = {"jobId", "countryId", "regionId", "LimitBreakCountryId", "LimitBreakJobId"}
		local countMap = {}

		for i, id in ipairs(deck) do
			if id == nil or id == "" then
				continue
			end

			local unit = _UnitService:GetUnitByIDFromServer(id)
			if unit == nil then
				continue
			end

			local buffedUnit = BuffedUnitModel()
			buffedUnit:Init(unit)

			local unitJson = _UserMonsterService.userMonsterDict[id]
			if unitJson ~= nil then
				local userUnitData = UserUnitModel()
				userUnitData:DECODE(unitJson)
				buffedUnit = _BuffedUnitService:SetUnitBuff(buffedUnit, userUnitData.level, userUnitData.limitBreak)
			end

			for j, col in ipairs(syncCols) do
				if buffedUnit[col] == nil then
					continue
				end
				if buffedUnit[col] == 0 then
					continue
				end

				local key = tostring(buffedUnit[col])
				if countMap[key] == nil then
					countMap[key] = 0
				end
				countMap[key] = countMap[key] + 1
			end
		end

		return countMap
	end

	@ExecSpace("Server")
	method void SetOffeseUnitCall(integer index, string unit_id)
		_ProtocolService:CommonCall(senderUserId)

		self.offense_deck[index] = unit_id
		self.offense_synergy = self:ComputeSynergy(self.offense_deck)

		local code = _pvpUserService:UpdateUserData(senderUserId, self.play_coin, self.next_play_coin, self.offense_deck, self.defense_deck, self.offense_synergy, self.defense_synergy)

		if not (code == 0) then
			return
		end

		self:SetOffenseUnitBack(self.offense_deck, self.offense_synergy)
	end

	@ExecSpace("Client")
	method void SetOffenseUnitBack(table deck, table synergy)
		self.offense_deck = deck
		self.offense_synergy = synergy
	end

	@ExecSpace("Server")
	method void SetDefenseUnitCall(integer index, string unit_id)
		_ProtocolService:CommonCall(senderUserId)

		self.defense_deck[index] = unit_id
		self.defense_synergy = self:ComputeSynergy(self.defense_deck)

		local code = _pvpUserService:UpdateUserData(senderUserId, self.play_coin, self.next_play_coin, self.offense_deck, self.defense_deck, self.offense_synergy, self.defense_synergy)

		if not (code == 0) then
			return
		end

		self:SetDefenseUnitBack(self.defense_deck, self.defense_synergy)
	end

	@ExecSpace("Client")
	method void SetDefenseUnitBack(table deck, table synergy)
		self.defense_deck = deck
		self.defense_synergy = synergy
	end

	@ExecSpace("ServerOnly")
	method void UseCoin(string userId)
		if not self:CanUseCoin() then
			return
		end

		self.play_coin -= 1

		local code = _pvpUserService:UpdateUserData(userId, self.play_coin, self.next_play_coin, self.offense_deck, self.defense_deck, self.offense_synergy, self.defense_synergy)

		if not (code == 0) then
			return
		end

		self:UserCoinBack(self.play_coin)
	end

	@ExecSpace("ServerOnly")
	method boolean CanUseCoin()
		return self.play_coin > 0
	end

	@EventSender("Service", "UserService")
	handler HandleUserEnterEvent(UserEnterEvent event)
		--------------- Native Event Sender Info ----------------
		-- Sender: UserService
		-- Space: Server
		---------------------------------------------------------

		-- Parameters
		-- local ProfileCode = event.ProfileCode
		-- local UserId = event.UserId
		---------------------------------------------------------
		self:GetUserDataCall()
	end

end