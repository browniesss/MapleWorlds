@Component
script pvpUserComponent extends Component

	property integer play_coin = 5

	property table offense_deck = {}

	property table defense_deck = {}

	property table offense_synergy = {}

	property table defense_synergy = {}

	property integer next_play_coin = 0

	property integer win_count = 0

	property integer play_count = 0

	property boolean dataLoaded = false

	@ExecSpace("ServerOnly")
	method void OnUpdate(number delta)
		local nowTs = DateTime.UtcNow.Elapsed
		if self.next_play_coin > nowTs then
			return
		end

		if self.play_coin >= 5 then
			return
		end

		local addCoin = math.floor((nowTs - self.next_play_coin) / _pvpUserService.PLAY_COIN_UPDATE) + 1

		self.play_coin += addCoin
		if self.play_coin > _pvpUserService.MAX_PLAY_COIN then
			self.play_coin = _pvpUserService.MAX_PLAY_COIN
		end

		self.next_play_coin = nowTs + _pvpUserService.PLAY_COIN_UPDATE

		self:UserCoinBack(self.play_coin)
		self:UpdateCoinNextTs(self.next_play_coin)
	end

	@ExecSpace("Server")
	method void GetUserDataCall()
		_ProtocolService:CommonCall(senderUserId)

		local data = _pvpUserService:GetUserData(senderUserId)
		if not (data.code == 0) then
			log_error("[PVP] fail at GetUserData uid=" .. senderUserId .. " code=" .. tostring(data.code))
			return
		end

		self.play_coin = data.play_coin
		self.next_play_coin = data.next_play_coin
		self.offense_deck = data.offense_deck
		self.defense_deck = data.defense_deck
		self.offense_synergy = data.offense_synergy
		self.defense_synergy = data.defense_synergy
		self.win_count = data.win_count
		self.play_count = data.play_count
		self.dataLoaded = true

		-- 닉네임 캐시 등록
		local userEntity = _UserService:GetUserEntityByUserId(senderUserId)
		if userEntity ~= nil and userEntity.PlayerComponent ~= nil then
			_pvpRankingService:RegisterNickname(senderUserId, userEntity.PlayerComponent.Nickname)
		end

		-- 공격덱/방어덱이 비어있으면 노멀 스테이지 덱을 복사
		local offenseEmpty = self:IsDeckEmpty(self.offense_deck)
		local defenseEmpty = self:IsDeckEmpty(self.defense_deck)
		if offenseEmpty or defenseEmpty then
			local normalDeck = self:LoadNormalDeck(senderUserId)
			if normalDeck ~= nil then
				if offenseEmpty then
					self.offense_deck = _pvpUserService:NormalizeDeck(normalDeck)
					self.offense_synergy = self:ComputeSynergy(self.offense_deck)
				end
				if defenseEmpty then
					self.defense_deck = _pvpUserService:NormalizeDeck(normalDeck)
					self.defense_synergy = self:ComputeSynergy(self.defense_deck)
				end
				_pvpUserService:UpdateUserData(senderUserId, self.play_coin, self.next_play_coin, self.offense_deck, self.defense_deck, self.offense_synergy, self.defense_synergy, self.win_count, self.play_count)
				data.offense_deck = self.offense_deck
				data.defense_deck = self.defense_deck
				data.offense_synergy = self.offense_synergy
				data.defense_synergy = self.defense_synergy
			end
		end

		-- 검증된 기존 콜백 재사용 (각 1~2 파라미터)
		self:UserCoinBack(data.play_coin)
		self:UpdateCoinNextTs(data.next_play_coin)
		self:SetOffenseUnitBack(data.offense_deck, data.offense_synergy)
		self:SetDefenseUnitBack(data.defense_deck, data.defense_synergy)
	end

	@ExecSpace("ClientOnly")
	method void RefreshPvPDeckUI()
		local deckPanel = _EntityService:GetEntityByPath("/ui/UserDeckUI/UserDeck")
		if deckPanel ~= nil and deckPanel.UserDeckUI ~= nil and deckPanel.UserDeckUI.pvpMode then
			deckPanel.UserDeckUI:LoadPvPDeck()
		end
	end

	@ExecSpace("Client")
	method void UserCoinBack(integer coin)
		self.play_coin = coin
		local pvpLobbyUI = _EntityService:GetEntityByPath("/ui/PvPLobbyUI")
		if pvpLobbyUI ~= nil and pvpLobbyUI.PvPLobbyUI ~= nil then
			pvpLobbyUI.PvPLobbyUI:UpdateCoinDisplay()
		end
	end

	@ExecSpace("Client")
	method void UpdateCoinNextTs(integer ts)
		self.next_play_coin = ts
	end

	method table NormalizeDeckClient(table deck)
		if deck == nil then
			return {"","","","","","","",""}
		end
		local result = {}
		for i = 1, 8 do
			local val = deck[i]
			if val == nil then
				val = deck[tostring(i)]
			end
			if val == nil or val == "" then
				result[i] = ""
			else
				result[i] = val
			end
		end
		return result
	end

	@ExecSpace("ServerOnly")
	method boolean IsDeckEmpty(table deck)
		if deck == nil then
			return true
		end
		for i = 1, 8 do
			local val = deck[i]
			if val == nil then
				val = deck[tostring(i)]
			end
			if val ~= nil and val ~= "" then
				return false
			end
		end
		return true
	end

	@ExecSpace("ServerOnly")
	method table LoadNormalDeck(string userId)
		local ds = _DataStorageService:GetUserDataStorage(userId)
		local errCode, res = ds:GetAndWait("USER_DECK")
		if errCode ~= 0 or res == nil then
			return nil
		end
		local resTable = _HttpService:JSONDecode(res)
		if resTable == nil or resTable["UserDeck"] == nil then
			return nil
		end
		return resTable["UserDeck"]
	end

	@ExecSpace("ServerOnly")
	method table ComputeSynergy(table deck)
		local syncCols = {"jobId", "countryId", "regionId", "LimitBreakCountryId", "LimitBreakJobId"}
		local countMap = {}

		for i, id in ipairs(deck) do
			if id == nil or id == "" then
				continue
			end

			local unit = _UnitService:GetUnitByIDFromServer(id)
			if unit == nil then
				continue
			end

			local buffedUnit = BuffedUnitModel()
			buffedUnit:Init(unit)

			local unitJson = _UserMonsterService.userMonsterDict[id]
			if unitJson ~= nil then
				local userUnitData = UserUnitModel()
				userUnitData:DECODE(unitJson)
				buffedUnit = _BuffedUnitService:SetUnitBuff(buffedUnit, userUnitData.level, userUnitData.limitBreak)
			end

			for j, col in ipairs(syncCols) do
				if buffedUnit[col] == nil then
					continue
				end
				if buffedUnit[col] == 0 then
					continue
				end

				local key = tostring(buffedUnit[col])
				if countMap[key] == nil then
					countMap[key] = 0
				end
				countMap[key] = countMap[key] + 1
			end
		end

		return countMap
	end

	@ExecSpace("Server")
	method void SetOffeseUnitCall(integer index, string unit_id)
		_ProtocolService:CommonCall(senderUserId)

		if not self.dataLoaded then
			log_error("[PVP] SetOffeseUnitCall before data loaded, uid=" .. senderUserId)
			return
		end

		self.offense_deck[index] = unit_id
		self.offense_synergy = self:ComputeSynergy(self.offense_deck)

		local code = _pvpUserService:UpdateUserData(senderUserId, self.play_coin, self.next_play_coin, self.offense_deck, self.defense_deck, self.offense_synergy, self.defense_synergy, self.win_count, self.play_count)

		if not (code == 0) then
			log_error("[PVP] SetOffeseUnitCall save failed, uid=" .. senderUserId .. " code=" .. tostring(code))
			return
		end

		self:SetOffenseUnitBack(self.offense_deck, self.offense_synergy)
	end

	@ExecSpace("Client")
	method void SetOffenseUnitBack(table deck, table synergy)
		self.offense_deck = self:NormalizeDeckClient(deck)
		self.offense_synergy = synergy
		self:RefreshPvPDeckUI()
	end

	@ExecSpace("Server")
	method void SetDefenseUnitCall(integer index, string unit_id)
		_ProtocolService:CommonCall(senderUserId)

		if not self.dataLoaded then
			log_error("[PVP] SetDefenseUnitCall before data loaded, uid=" .. senderUserId)
			return
		end

		self.defense_deck[index] = unit_id
		self.defense_synergy = self:ComputeSynergy(self.defense_deck)

		local code = _pvpUserService:UpdateUserData(senderUserId, self.play_coin, self.next_play_coin, self.offense_deck, self.defense_deck, self.offense_synergy, self.defense_synergy, self.win_count, self.play_count)

		if not (code == 0) then
			log_error("[PVP] SetDefenseUnitCall save failed, uid=" .. senderUserId .. " code=" .. tostring(code))
			return
		end

		self:SetDefenseUnitBack(self.defense_deck, self.defense_synergy)
	end

	@ExecSpace("Client")
	method void SetDefenseUnitBack(table deck, table synergy)
		self.defense_deck = self:NormalizeDeckClient(deck)
		self.defense_synergy = synergy
		self:RefreshPvPDeckUI()
	end

	@ExecSpace("ServerOnly")
	method void UseCoin(string userId)
		if not self:CanUseCoin() then
			return
		end

		if not self.dataLoaded then
			log_error("[PVP] UseCoin before data loaded, uid=" .. userId)
			return
		end

		self.play_coin -= 1
		if self.play_coin < _pvpUserService.MAX_PLAY_COIN then
			self.next_play_coin = DateTime.UtcNow.Elapsed + _pvpUserService.PLAY_COIN_UPDATE
		end

		local code = _pvpUserService:UpdateUserData(userId, self.play_coin, self.next_play_coin, self.offense_deck, self.defense_deck, self.offense_synergy, self.defense_synergy, self.win_count, self.play_count)

		if not (code == 0) then
			log_error("[PVP] UseCoin save failed, uid=" .. userId .. " code=" .. tostring(code))
			return
		end

		self:UserCoinBack(self.play_coin)
		self:UpdateCoinNextTs(self.next_play_coin)
	end

	@ExecSpace("ServerOnly")
	method boolean CanUseCoin()
		return self.play_coin > 0
	end

	@ExecSpace("ServerOnly")
	method void AddGameResult(string userId, boolean isWin)
		self.play_count += 1
		if isWin then
			self.win_count += 1
		end
		_pvpUserService:UpdateUserData(userId, self.play_coin, self.next_play_coin, self.offense_deck, self.defense_deck, self.offense_synergy, self.defense_synergy, self.win_count, self.play_count)
		self:SyncRecordBack(self.win_count, self.play_count)
	end

	@ExecSpace("Client")
	method void SyncRecordBack(integer win, integer total)
		self.win_count = win
		self.play_count = total
	end

	@ExecSpace("ClientOnly")
	method void OnBeginPlay()
		self:GetUserDataCall()
	end

end
