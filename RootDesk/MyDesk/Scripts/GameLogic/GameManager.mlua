@Logic
script GameManager extends Logic

	property Entity skillSelectUI = "ec7b9d8d-b2c2-4ee8-b95c-58564c8a4763"

	property SyncTable<Entity> skillBtn

	property Entity shopUI = "e0ec4a39-4a35-4e17-95aa-c16dee01f5fa"

	property Entity infoUI = "a07f182a-214a-414d-b995-9863eaa71d62"

	property Entity unitShop = "fa5581b7-25d8-40c7-8b0f-ea16534303e2"

	property Entity skillSlots = "847312aa-e2d9-4375-9707-b0a2000cf8c0"

	@Sync
	property integer chapterIndex = 0

	@Sync
	property integer mapIndex = 0

	@Sync
	property boolean isTest = false

	@Sync
	property integer playStartTs = 0

	property Entity timeText = "f229ed5a-4dbc-4c26-8ff0-3fa8ebf7f5ce"

	@Sync
	property boolean isPlaying = false

	@Sync
	property integer timer = 0

	property Entity gameClearResult = "bd109aaa-b307-4160-b918-a09b05a6d4d9"

	property RankUI rankUI = "daa5b02b-f478-4f97-a216-d17e6b71634a"

	property Entity failPopupUI = "6f1b960c-08f8-41f2-93e4-3e585ec70ab8"

	property Entity joystick = "02c6fd20-fdb0-4b80-bbd3-2241e929c46d"

	property Entity screenSkillUI = "c735233f-679d-4f6d-a9c2-ab9db46c5bd6"

	property Entity mapTextUI = "1374988d-d50e-4f9c-8bb8-e158f9b3decf"

	@Sync
	property boolean isTutorialMode = false

	@Sync
	property boolean isTutorialPaused = false

	@Sync
	property boolean isEventMode = false

	@Sync
	property boolean isHardMode = false

	property string hardModeMaterialId = "c3d80f81-fdbe-4304-aeb6-4ee73d86f120"

	@ExecSpace("ClientOnly")
	method void OnBeginPlay()
		-- 스킬 선택 UI 비활성화
		-- for i = 1, 3 do
			-- table.insert(self.skillBtn, self.skillSelectUI.Children[i])
		-- end
	end

	@ExecSpace("Client")
	method void OpenSkillSelect()
		_TweenLogic:MoveTo(self.skillSelectUI, Vector2(0, 0), 0.3, EaseType.CircEaseIn)
		
		local currentIngameSkills = _UserService.LocalPlayer.PlayerCharacter.ingameSkills
		local allSkillData = _SkillManager.ingameSkillData
		
		-- 후보 스킬 목록 생성
		local availableSkills = {}
		for skillID, baseData in pairs(allSkillData) do
		    local currentLevel = currentIngameSkills[skillID] or 0
		    if currentLevel < baseData["maxLevel"] then
		        table.insert(availableSkills, skillID)
		    end
		end
		
		-- 선택할 수 있는 스킬 수 결정 (최대 3개)
		local choiceCount = math.min(3, #availableSkills)
		if choiceCount == 0 then
		    return
		end
		
		-- 랜덤으로 3개 뽑기
		for i = 1, choiceCount do
		    local index = math.random(1, #availableSkills)
		    local skillID = availableSkills[index]
		    local skillData = allSkillData[skillID]
		    table.remove(availableSkills, index)  -- 같은 스킬 중복 방지
		
			local currentLevel = currentIngameSkills[skillID] or 0
		    local descList = _UtilLogic:Split(skillData["desc"], "|")
		    local descIndex = math.min(currentLevel + 1, #descList)  -- 선택창은 "다음 레벨" 설명을 보여주기 위해 +1
		
		    local selectedDesc = descList[descIndex] or "설명이 없습니다."
		
		    -- UI 버튼에 정보 넣기
		    self.skillBtn[i].Children[1].SpriteGUIRendererComponent.ImageRUID = skillData["icon"]
		    self.skillBtn[i].Children[2].TextComponent.Text = skillData["name"]
		    self.skillBtn[i].Children[3].TextComponent.Text = selectedDesc
		    self.skillBtn[i].SkillButton.skillID = skillID
		end
		
		-- 만약 선택지 수가 3개 미만이면 나머지 버튼은 비활성화
		for i = choiceCount + 1, 3 do
		    self.skillBtn[i].Children[1].SpriteGUIRendererComponent.ImageRUID = ""
		    self.skillBtn[i].Children[2].TextComponent.Text = ""
		    self.skillBtn[i].Children[3].TextComponent.Text = ""
		    self.skillBtn[i].SkillButton.skillID = nil
		end
	end

	@ExecSpace("Client")
	method void CloseSkillSelect()
		_TweenLogic:MoveTo(self.skillSelectUI, Vector2(0, -800), 0.3, EaseType.CircEaseOut)
	end

	@ExecSpace("Server")
	method void GameStart(integer chapterIndex, integer mapIndex, boolean isEventMode, boolean isHardMode)
		self.chapterIndex = chapterIndex
		self.mapIndex = mapIndex
		self.isPlaying = true
		self.playStartTs = DateTime.UtcNow.Elapsed
		self.isEventMode = isEventMode
		self.isHardMode = isHardMode or false
		self:SyncEventMode(isEventMode)
		
		local userIncome = _SpawnManager:GetUserIncome()
		local baseIncomeData = userIncome.MesoIncome:GetMesoData()
		local meso = baseIncomeData.init
		local income = baseIncomeData.income
		if senderUserId ~= nil then
			local user = _UserService:GetUserEntityByUserId(senderUserId)
			
			local addInitPoint = 5
			local count = user.UserSynergyComponent:GET_SYNERGY_COUNT(addInitPoint)
			local synergy = _SynergyRepo:FIND_SYNERGY_AVAILABLE(tostring(addInitPoint), count)
				log(addInitPoint, " => ", count)
			
			if synergy:length() > 0 then
				local item = synergy:Get(1)
				log("add init point" , meso, " => ", item:CalcValue(meso))
				meso += item:CalcValue(meso)
			end
			
			local addPointRatio = 101
			local addPointRatioCount = user.UserSynergyComponent:GET_SYNERGY_COUNT(addPointRatio)
			local addPointRatioSynergy = _SynergyRepo:FIND_SYNERGY_AVAILABLE(tostring(addPointRatio), addPointRatioCount)
			log(addPointRatio, " => ", addPointRatioCount)
			
			if addPointRatioSynergy:length() > 0 then
				local item = addPointRatioSynergy:Get(1)
				log("add income point" , income, " => ", item:CalcValue(income))
				income += item:CalcValue(income)
			end
		end
		
		userIncome.MesoIncome:InitData(meso, income)
		
		local key = _RankingService:GetRankKeyByTable({chapter=chapterIndex, stage=mapIndex})
		
		self:SetPlayerCharacter()
		
		self:SetTimer()
		self:GameStartDataInClient(chapterIndex, mapIndex)
		self:EnableUI()
		
		local stageData
		if self.isEventMode then
			local eventIdValue = tostring(_EventService.currentEventVersion)
			stageData = _EventService:GetEventStageByIdFromServer(eventIdValue, chapterIndex, mapIndex)
		else
			stageData = _StageService:GetStageByIdFromServer(tostring(mapIndex + 100 * chapterIndex))
		end
		local playerTower = _EntityService:GetEntityByPath(self:GetGameMapName().."/PlayerTower")
		local enemyTower = _EntityService:GetEntityByPath(self:GetGameMapName().."/EnemyTower")
		local ourHealthBar = _EntityService:GetEntityByPath("/ui/Ingame_Info_UI_Group/Player_HP_bar")
		local enemyHealthBar = _EntityService:GetEntityByPath("/ui/Ingame_Info_UI_Group/EnemyHealthBar")
		
		if stageData ~= nil then
			enemyTower.Unit.originMaxHP = stageData["enemy_tower_hp"]
			enemyTower.Unit.maxHP = stageData["enemy_tower_hp"]
			enemyTower.Unit.hp = stageData["enemy_tower_hp"]
		end
		playerTower.Unit.originMaxHP = 500
		playerTower.Unit.maxHP = 500
		playerTower.Unit.hp = 500
	end

	@ExecSpace("Client")
	method void GameStartDataInClient(integer chapterIndex, integer mapIndex)
		self.chapterIndex = chapterIndex
		self.mapIndex = mapIndex
		
		
		local ourHealthBarUI = _EntityService:GetEntityByPath("/ui/Ingame_Info_UI_Group/Player_HP_bar")
		local enemyHealthBarUI = _EntityService:GetEntityByPath("/ui/Ingame_Info_UI_Group/EnemyHealthBar")
		local playerTower = _EntityService:GetEntityByPath(self:GetGameMapName().."/PlayerTower")
		local enemyTower = _EntityService:GetEntityByPath(self:GetGameMapName().."/EnemyTower")
		
		ourHealthBarUI.OurHealthBar.tower = playerTower
		enemyHealthBarUI.EnemyHealthBar.tower = enemyTower
		
		if self.isEventMode then
			local eventIdValue = tostring(_EventService.currentEventVersion)
			local eventStage = _EventService:GetEventStageById(eventIdValue, chapterIndex, mapIndex)
			if eventStage ~= nil then
				self.mapTextUI.TextComponent.Text = eventStage.name
			end
		else
			self.mapTextUI.TextComponent.Text = _StageService:GetStageById(tostring(chapterIndex * 100 + mapIndex)).name
		end
	end

	method void GameEnd()
		-- 몬스터 도감 킬 데이터 서버로 동기화
		_MonsterCodexService:SyncKillDataToServer()
		
		-- 인게임 UI 비활성화
		self.shopUI.Enable = false
		self.shopUI.Visible = false
		self.infoUI.Enable = false
		self.infoUI.Visible = false
		self.gameClearResult.Enable = false
		self.gameClearResult.Visible = false
		self.failPopupUI.Enable = false
		self.failPopupUI.Visible = false
		
		self.isEventMode = false
		self:SyncEventMode(false)
		
		self:ClearObjects()
		self:ClearTimer()
		self:ClearGameData()
		self:ClearGameDataInClient()
	end

	method string GetGameMapName()
		if self.isTest then
			return "/maps/TestMap"
		end
		
		if self.isEventMode then
			local chapterStr = "" .. self.chapterIndex
			local mapStr = "" .. self.mapIndex
			if self.chapterIndex < 10 then
				chapterStr = "0" .. self.chapterIndex
			end
			if self.mapIndex < 10 then
				mapStr = "0" .. self.mapIndex
			end
			return "/maps/Event" .. chapterStr .. mapStr
		end
		
		return "/maps/Stage"..self.chapterIndex.."0"..self.mapIndex
	end

	@ExecSpace("Client")
	method void EnableUI()
		-- 인게임 UI 활성화
		self.shopUI.Enable = true
		self.shopUI.Visible = true
		self.infoUI.Enable = true
		self.infoUI.Visible = true
		self.gameClearResult.Enable = false
		self.gameClearResult.Visible = false
		self.joystick.Enable = false
		self.joystick.Visible = false
		
		-- 불필요한 UI 비활성화
		self.failPopupUI.Enable = false
		self.failPopupUI.Visible = false
		
		-- 모바일 환경 지원
		if Environment:IsMobilePlatform() then
			self.joystick.Enable = true
			self.joystick.Visible = true
		end
		
		
		-- 닉네임 설정
		local userNameUI = _EntityService:GetEntityByPath("/ui/Ingame_Info_UI_Group/UserInfo/UserName")
		userNameUI.TextComponent.Text = _UserService.LocalPlayer.PlayerComponent.Nickname
		
		-- Stage000 (튜토리얼 스테이지) 진입 시 인게임 튜토리얼 시작
		if self.chapterIndex == 0 and self.mapIndex == 0 then
			self.isTutorialMode = true
		
			-- 튜토리얼용 덱 설정: 첫 번째 카드를 히어로로 스왑 (InitShop 전에 설정해야 함)
			local player = _EntityService:GetEntityByTag("Player")
			if player ~= nil and player.UserDeck ~= nil then
				local heroId = "model://494916e1-eeaa-4318-b36f-95d40d6c5e91"
				local userDeck = player.UserDeck.userDeck
		
				-- 히어로가 덱에 있는지 찾기
				local heroIndex = nil
				for i = 1, 8 do
					if userDeck[i] == heroId then
						heroIndex = i
						break
					end
				end
		
				-- 히어로가 있으면 첫 번째 카드와 스왑
				if heroIndex ~= nil and heroIndex ~= 1 then
					userDeck[heroIndex] = userDeck[1]
					userDeck[1] = heroId
				elseif heroIndex == nil then
					-- 히어로가 덱에 없으면 첫 번째 카드를 히어로로 교체
					userDeck[1] = heroId
				end
			end
		end
		
		self.unitShop.UnitShop:InitShop()
		
		for i = 1, 2 do
		    local child = self.skillSlots.Children[i]
		    if child ~= nil then
				child.SkillSlot:Initialize()
		    end
		end
		
		-- 튜토리얼 모드일 때 튜토리얼 시작
		if self.isTutorialMode then
			-- 약간의 딜레이 후 튜토리얼 시작 (UI 로드 완료 대기)
			_TimerService:SetTimerOnce(function()
				if _TutorialService ~= nil then
					_TutorialService:StartIngameTutorial(1)
				end
			end, 0.5)
		end
		
		-- 하드모드 배경 Material 적용
		self:ApplyHardModeBackgroundMaterial()
	end

	@ExecSpace("Client")
	method void ApplyHardModeBackgroundMaterial()
		-- 클라이언트에서 isHardMode 값 가져오기 (서버 동기화 전에 호출될 수 있으므로 StageSelectorUI에서 가져옴)
		local isHardMode = false
		local stageSelectUI = _EntityService:GetEntityByPath("/ui/LobbyInfoUI/SelectUI/StageSelectUI")
		if stageSelectUI ~= nil and stageSelectUI.StageSelectorUI ~= nil then
			isHardMode = stageSelectUI.StageSelectorUI.isHardMode or false
		end
		
		-- 현재 맵의 Background 엔티티 찾기
		local mapPath = self:GetGameMapName()
		local backgroundEntity = _EntityService:GetEntityByPath(mapPath .. "/Background")
		
		-- Background가 있고 Enable이 true인 경우 BackgroundComponent 사용
		if backgroundEntity ~= nil and backgroundEntity.Enable == true then
			if backgroundEntity.BackgroundComponent ~= nil then
				if isHardMode then
					backgroundEntity.BackgroundComponent.MaterialId = self.hardModeMaterialId
				else
					backgroundEntity.BackgroundComponent.MaterialId = ""
				end
				return
			end
		end
		
		-- Background가 없거나 Enable이 false인 경우 TemporaryBackground들 처리
		local tempBackgrounds = _EntityService:GetEntitiesByPath(mapPath .. "/TemporaryBackground")
		
		if tempBackgrounds == nil or #tempBackgrounds == 0 then
			return
		end
		
		for i, tempBg in ipairs(tempBackgrounds) do
			if tempBg ~= nil and tempBg.BackgroundComponent ~= nil then
				if isHardMode then
					tempBg.BackgroundComponent.MaterialId = self.hardModeMaterialId
				else
					tempBg.BackgroundComponent.MaterialId = ""
				end
			end
		end
	end

	@ExecSpace("Client")
	method void SetPlayerCharacter()
		local player = _UserService.LocalPlayer.UserSkillDeck
		
		
		local skill1 = _SkillService:GetSkillByIDFromClient(player.userSkillDeck[1])
		local skill2 = _SkillService:GetSkillByIDFromClient(player.userSkillDeck[2])
		
		_UserService.LocalPlayer.PlayerCharacter:SetSkill(skill1, skill2)
	end

	method void ClearObjects()
		local myMonsterList = _EntityService:GetEntityByPath(self:GetGameMapName().."/MyMonsterList")
		local enemyList = _EntityService:GetEntityByPath(self:GetGameMapName().."/EnemyList")
		local skillParent = _EntityService:GetEntityByPath(self:GetGameMapName().."/SkillParent")
		local ProjectileParent = _EntityService:GetEntityByPath(self:GetGameMapName().."/ProjectileParent")
		local minimap = _EntityService:GetEntityByPath("/ui/Ingame_Info_UI_Group/Minimap Group/Minimap Background")
		local timeText = _EntityService:GetEntityByPath("/ui/Ingame_Info_UI_Group/CenterUI/TimeText")
		
		-- 첫 번째 자식은 유지
		self:DestroyChildren(myMonsterList, true)
		self:DestroyChildren(enemyList, true)
		self:DestroyChildrenInClient(minimap, true)
		
		-- 전부 삭제
		self:DestroyChildren(skillParent, false)
		self:DestroyChildren(ProjectileParent, false)
		
		timeText.TextComponent.Text = "0:00"
	end

	@ExecSpace("Server")
	method void DestroyChildren(Entity entity, boolean keepFirst)
		if not entity or not entity.Children then return end
			local targets = {}
			for idx, child in ipairs(entity.Children) do
				if not keepFirst or idx ~= 1 then
					table.insert(targets, child)
				end
			end
			for _, e in ipairs(targets) do
				if e and e.Destroy then
					e:Destroy()
				end
			end
	end

	@ExecSpace("Client")
	method void DestroyChildrenInClient(Entity entity, boolean keepFirst)
		if not entity or not entity.Children then return end
			local targets = {}
			for idx, child in ipairs(entity.Children) do
				if not keepFirst or idx ~= 1 then
					table.insert(targets, child)
				end
			end
			for _, e in ipairs(targets) do
				if e and e.Destroy then
					e:Destroy()
				end
			end
	end

	@ExecSpace("Server")
	method void SetTimer()
		self.timer = _TimerService:SetTimerRepeat(function()
			local playTime = DateTime.UtcNow.Elapsed - self.playStartTs
			
			self:SetTimeText(playTime)
		end, 1.0, 0)
	end

	@ExecSpace("Server")
	method void ClearTimer()
		self.playStartTs = 0
		_TimerService:ClearTimer(self.timer)
	end

	@ExecSpace("Client")
	method void SetTimeText(integer playTime)
		self.timeText.TextComponent.Text = self:FormatMMSS(playTime / 1000)
	end

	@ExecSpace("Server")
	method void ClearGameData()
		self.isPlaying = false
		
		local mesoWallet = _EntityService:GetEntityByPath(_GameManager:GetGameMapName() .. "/userWallet")
		
		mesoWallet.MesoWallet:SetMeso(0) 
	end

	@ExecSpace("Client")
	method void ClearGameDataInClient()
		local skillSlots = _EntityService:GetEntityByPath("/ui/Ingame_Shop_Group/SkillSlots")
		
		for i = 1, 2 do
			skillSlots.Children[i].SkillSlot.remainingTime = 0
			skillSlots.Children[i].Children[2].SpriteGUIRendererComponent.FillAmount = 0
		end
	end

	method string FormatMMSS(number time)
		local s = math.max(0, math.floor(time))
		local m = math.floor(s / 60)
		local ss = s % 60
		
		return string.format("%d:%02d", m, ss)
	end

	@ExecSpace("Client")
	method void StageClear()
		local userStage = _UserService.LocalPlayer.UserStage
		
		self:Log_NormalStageClear()
		
		local clearedChapter = userStage.selectChapter
		local clearedStage = userStage.selectStage
		
		-- 서버에서 실제 최초 클리어 판정 및 보상 처리 (UI 업데이트는 콜백에서)
		self:StageClearServer(clearedChapter, clearedStage)
	end

	@ExecSpace("Client")
	method void StageClearClientCallback(boolean isFirstClear, integer eventToken)
		local userAvatar = _EntityService:GetEntityByPath("/ui/GameClearUI/Frame/UserAvatar/UnitAvartar")
		local clearRewardUI = _EntityService:GetEntityByPath("/ui/GameClearUI/Frame/ClearReward")
		
		if eventToken == nil then
			eventToken = 0
		end
		
		self.gameClearResult.Enable = true
		self.gameClearResult.Visible = true
		clearRewardUI.ClearRewardUI:RefreshUI(isFirstClear, self.isEventMode, eventToken)
		
		-- 이벤트 모드에서는 랭킹 UI 비활성화
		if self.rankUI ~= nil then
			local rankEntity = self.rankUI.Entity
			if self.isEventMode then
				rankEntity.Enable = false
				rankEntity.Visible = false
			else
				rankEntity.Enable = true
				rankEntity.Visible = true
			end
		end
		
		_Utils:FadeIn(self.gameClearResult, 0.5)
		
		userAvatar.AvatarGUIRendererComponent:PlayEmotion(EmotionalType.Love, 100)
	end

	@ExecSpace("Server")
	method void StageClearServer(integer clearedChapter, integer clearedStage)
		-- 튜토리얼 스테이지(0,0)는 보상/랭킹/진행도 저장 없이 UI만 표시
		if clearedChapter == 0 and clearedStage == 0 then
			self:StageClearClientCallback(false, 0, senderUserId)
			_UserService:GetUserEntityByUserId(senderUserId).UserStage:SetClearStage(1, 1)
			return
		end
		
		local user = _UserService:GetUserEntityByUserId(senderUserId)
		local userStage = user.UserStage
		local userName = user.PlayerComponent.Nickname
		local playTime = DateTime.UtcNow.Elapsed - self.playStartTs
		
		-- 하드모드 여부에 따라 랭킹 키 분기
		local key = nil
		if self.isHardMode then
			key = _RankingService:GetRankKeyByTable({chapter=clearedChapter, stage=clearedStage, mode="hard"})
		else
			key = _RankingService:GetRankKeyByTable({chapter=clearedChapter, stage=clearedStage})
		end
		_RankingService:AddPoint(key, userName, playTime)
		
		self:UpdateRankData(userName, playTime, key, senderUserId)
		
		-- 서버에서 최초 클리어 판정 (하드/노말 분리)
		local isFirstClear = false
		local isNewStage = false
		local isNotCleared = false

		if self.isHardMode then
			-- 하드모드 기준
			isNewStage = (clearedChapter > userStage.hardOpenChapter) or
				(clearedChapter == userStage.hardOpenChapter and clearedStage >= userStage.hardOpenStage)
			isNotCleared = not userStage:IsHardStageCleared(clearedChapter, clearedStage)
		else
			-- 노말모드 기준
			isNewStage = (clearedChapter > userStage.openChapter) or
				(clearedChapter == userStage.openChapter and clearedStage >= userStage.openStage)
			isNotCleared = not userStage:IsStageCleared(clearedChapter, clearedStage)
		end

		if isNewStage and isNotCleared then
			isFirstClear = true
		end
		
		print(string.format("[GameManager] StageClearServer: userId=%s, isHardMode=%s, isFirstClear=%s, clearedChapter=%s, clearedStage=%s, isNewStage=%s, isNotCleared=%s",
			senderUserId, tostring(self.isHardMode), tostring(isFirstClear), tostring(clearedChapter), tostring(clearedStage), tostring(isNewStage), tostring(isNotCleared)))
		
		-- 클라이언트 UI 업데이트 콜백 (일반 모드는 토큰 0)
		self:StageClearClientCallback(isFirstClear, 0, senderUserId)
		
		-- 최초 클리어: cleared 목록에 추가 및 다음 스테이지 오픈 (노말/하드 분리)
		if self.isHardMode then
			-- 하드모드 진행
			print(string.format("[GameManager] Hard mode: current hardOpen=%d-%d, clearedStage=%d-%d, IsClearHardStage=%s",
				userStage.hardOpenChapter, userStage.hardOpenStage, clearedChapter, clearedStage, tostring(userStage:IsClearHardStage(clearedChapter, clearedStage))))
			if userStage:IsClearHardStage(clearedChapter, clearedStage) == false then
				local nextStage = _StageService:GetNextOpenStageIdFromServer(userStage.hardOpenChapter, userStage.hardOpenStage)
				print(string.format("[GameManager] Hard mode: nextStage=%d-%d", nextStage.chapter, nextStage.stage))
				if nextStage.chapter ~= userStage.hardOpenChapter or nextStage.stage ~= userStage.hardOpenStage then
					print(string.format("[GameManager] Hard mode: Opening next stage %d-%d", nextStage.chapter, nextStage.stage))
					userStage:SetClearHardStage(nextStage.chapter, nextStage.stage)
				end
			end
			userStage:AddClearedHardStage(clearedChapter, clearedStage)
		else
			-- 노말모드 진행
			-- 기존 클리어 여부와 관계없이 다음 스테이지 오픈 체크 (새 챕터 추가 시 기존 유저도 다음 챕터 진행 가능하도록)
			local nextStage = _StageService:GetNextOpenStageIdFromServer(userStage.openChapter, userStage.openStage)
			if nextStage.chapter ~= userStage.openChapter or nextStage.stage ~= userStage.openStage then
				userStage:SetClearStage(nextStage.chapter, nextStage.stage)
			end
			userStage:AddClearedStage(clearedChapter, clearedStage)
		end
		
		-- 하드모드 보상 배율
		local rewardMultiplier = 1
		if self.isHardMode then
			rewardMultiplier = 1.5
		end
		
		if isFirstClear == false then
			_BillingService:AddSecondFreeCoin(senderUserId, 100 * rewardMultiplier)
			_BillingService:AddThirdFreeCoin(senderUserId, 500 * rewardMultiplier)
		
			print("[GameManager] Not first clear, skipping badge check")
			return
		end
		
		_PlayCoinService:AddCoin(senderUserId, 1)
		_BillingService:AddSecondFreeCoin(senderUserId, 500 * rewardMultiplier)
		_BillingService:AddFirstFreeCoin(senderUserId, 100 * rewardMultiplier)
		_BillingService:AddThirdFreeCoin(senderUserId, 4000 * rewardMultiplier)
		
		print("[GameManager] First clear! Checking badges...")
		
		local isChapterComplete = false
		if clearedChapter == 1 and clearedStage == 5 then
			isChapterComplete = true
		elseif clearedChapter == 8 and clearedStage == 4 then
			isChapterComplete = true
		elseif clearedChapter >= 2 and clearedChapter ~= 8 and clearedStage == 6 then
			isChapterComplete = true
		end
		
		if isChapterComplete then
			print(string.format("[GameManager] Chapter %s completed! Checking chapter badge...", tostring(clearedChapter)))
			_BadgeConditionService:CheckChapterBadges(senderUserId, clearedChapter)
		end
		
		_BadgeConditionService:CheckStageBadges(senderUserId, clearedChapter, clearedStage)
	end

	method table GetPreLoadAssetRuid()
		local ruids = {}
		local playerDeck = _EntityService:GetEntityByTag("Player").UserDeck
		
		for i = 1, 8 do
			local unitData = _UnitService:GetUnitByIDFromClient(playerDeck.userDeck[i])
			local skillData = _SkillService:GetSkillByIDFromClient(unitData["skillID"])
			local spawnSkillData = _SkillService:GetSkillByIDFromClient(unitData["spawnSkill"])
			
			local ruidString = skillData["ruids"] or ""
		    
		    -- 쉼표로 분리된 string을 table로 변환
		    for ruid in string.gmatch(ruidString, "([^,]+)") do
		        table.insert(ruids, ruid)
		    end
			
			if spawnSkillData ~= nil then
				local spawnSkillruidString = spawnSkillData["ruids"] or ""
				-- 쉼표로 분리된 string을 table로 변환
		    	for ruid in string.gmatch(spawnSkillruidString, "([^,]+)") do
		        	table.insert(ruids, ruid)
		    	end
			end
		end
		
		return ruids
	end

	@ExecSpace("Client")
	method void LocalGameStart()
		local userStage = _UserService.LocalPlayer.UserStage

		-- 하드모드 상태 가져오기
		local isHardMode = false
		local stageSelector = _EntityService:GetEntityByPath("/ui/LobbyInfoUI/SelectUI/StageSelectUI")
		if stageSelector ~= nil and stageSelector.StageSelectorUI ~= nil then
			isHardMode = stageSelector.StageSelectorUI.isHardMode or false
		end

		if isHardMode then
			-- 하드모드: 해당 스테이지의 노말모드가 클리어되어 있어야 함
			-- 노말모드 클리어 여부는 openChapter/openStage로 판단
			-- selectChapter < openChapter 이거나, selectChapter == openChapter and selectStage < openStage 이면 클리어됨
			local isNormalCleared = (userStage.selectChapter < userStage.openChapter) or
				(userStage.selectChapter == userStage.openChapter and userStage.selectStage < userStage.openStage)
			if not isNormalCleared then
				-- 노말모드 미클리어 시 안내 UI 표시
				local hardInfoUI = _EntityService:GetEntityByPath("/ui/LobbyInfoUI/HardInfoUI")
				if hardInfoUI ~= nil then
					hardInfoUI.Visible = true
				end
				return
			end

			-- 하드모드 오픈 상태 체크
			if userStage.hardOpenChapter < userStage.selectChapter then
				local hardInfoUI = _EntityService:GetEntityByPath("/ui/LobbyInfoUI/HardInfoUI")
				if hardInfoUI ~= nil then
					hardInfoUI.Visible = true
				end
				return
			end
			if userStage.hardOpenChapter == userStage.selectChapter and userStage.hardOpenStage < userStage.selectStage then
				local hardInfoUI = _EntityService:GetEntityByPath("/ui/LobbyInfoUI/HardInfoUI")
				if hardInfoUI ~= nil then
					hardInfoUI.Visible = true
				end
				return
			end
		else
			-- 노말모드: 기존 로직
			if userStage.openChapter < userStage.selectChapter then
				return
			end
			if userStage.openChapter == userStage.selectChapter and userStage.openStage < userStage.selectStage then
				return
			end
		end
		
		_EntityService:GetEntityByPath("/ui/LobbyInfoUI").Enable = false
		local lobbyBadgeButton = _EntityService:GetEntityByPath("/ui/MainLobbyUI/UIRoot/TopUI/BadgeButton")
		lobbyBadgeButton.Enable = false
		local lobbyCodexButton = _EntityService:GetEntityByPath("/ui/MainLobbyUI/UIRoot/TopUI/CodexButton")
		if lobbyCodexButton ~= nil then
			lobbyCodexButton.Enable = false
		end
		
		if Environment:IsMobilePlatform() then
			local lobbyJoyStick = _EntityService:GetEntityByPath("/ui/MainLobbyUI/UIJoystick")
			local lobbyJumpButton = _EntityService:GetEntityByPath("/ui/MainLobbyUI/JumpButton")
		
			lobbyJoyStick.Enable = false
			lobbyJumpButton.Enable = false
		end
		
		_LoadingManager:Show()
		
		-- 돌파스킬 초기화 완료 후 프리로드 시작
		_UserService.LocalPlayer.UserBreakLimitSkillProtocol:InitCallWithCallback(function(limitBreakRuids)
			local ruids = self:GetPreLoadAssetRuid()
		
			-- 돌파스킬 ruids 추가
			for _, ruid in ipairs(limitBreakRuids) do
				table.insert(ruids, ruid)
			end
		
			_ResourceService:PreloadAsync(ruids, function()
				_TeleportService:TeleportToMapPosition(_UserService.LocalPlayer, Vector3.zero, "Stage".. userStage.selectChapter.."0"..userStage.selectStage)
				self:GameStart(userStage.selectChapter, userStage.selectStage, false, isHardMode)
			end)
		end)
	end

	@ExecSpace("Client")
	method void OpenZeroEnterCoinUI()
		local popupUI = _EntityService:GetEntityByPath("/ui/LobbyInfoUI/ZeroEnterCoinUI")
		popupUI.Visible = true
	end

	@ExecSpace("Client")
	method void LocalEventGameStart()
		local userStage = _UserService.LocalPlayer.UserStage
		if userStage.eventOpenChapter < userStage.eventSelectChapter then
			return
		end
		
		if userStage.eventOpenChapter == userStage.eventSelectChapter and userStage.eventOpenStage < userStage.eventSelectStage then
			return
		end
		
		_EntityService:GetEntityByPath("/ui/LobbyInfoUI").Enable = false
		local lobbyBadgeButton = _EntityService:GetEntityByPath("/ui/MainLobbyUI/UIRoot/TopUI/BadgeButton")
		lobbyBadgeButton.Enable = false
		local lobbyCodexButton = _EntityService:GetEntityByPath("/ui/MainLobbyUI/UIRoot/TopUI/CodexButton")
		if lobbyCodexButton ~= nil then
			lobbyCodexButton.Enable = false
		end
		
		if Environment:IsMobilePlatform() then
			local lobbyJoyStick = _EntityService:GetEntityByPath("/ui/MainLobbyUI/UIJoystick")
			local lobbyJumpButton = _EntityService:GetEntityByPath("/ui/MainLobbyUI/JumpButton")
		
			lobbyJoyStick.Enable = false
			lobbyJumpButton.Enable = false
		end
		
		_LoadingManager:Show()
		
		_UserService.LocalPlayer.UserBreakLimitSkillProtocol:InitCallWithCallback(function(limitBreakRuids)
			local ruids = self:GetPreLoadAssetRuid()
		
			for _, ruid in ipairs(limitBreakRuids) do
				table.insert(ruids, ruid)
			end
		
			_ResourceService:PreloadAsync(ruids, function()
				local mapName = "Event" .. string.format("%02d", userStage.eventSelectChapter) .. string.format("%02d", userStage.eventSelectStage)
				_TeleportService:TeleportToMapPosition(_UserService.LocalPlayer, Vector3.zero, mapName)
				self:EventGameStart(userStage.eventSelectChapter, userStage.eventSelectStage)
			end)
		end)
	end

	@ExecSpace("Server")
	method void EventGameStart(integer chapterIndex, integer mapIndex)
		self:GameStart(chapterIndex, mapIndex, true, false)
	end

	@ExecSpace("Client")
	method void EventStageClear()
		local userStage = _UserService.LocalPlayer.UserStage
		
		self:Log_EventStageClear()
		
		local clearedChapter = userStage.eventSelectChapter
		local clearedStage = userStage.eventSelectStage
		
		self:EventStageClearServer(clearedChapter, clearedStage)
	end

	@ExecSpace("Server")
	method void EventStageClearServer(integer clearedChapter, integer clearedStage)
		local user = _UserService:GetUserEntityByUserId(senderUserId)
		local userStage = user.UserStage
		local playTime = DateTime.UtcNow.Elapsed - self.playStartTs
		
		local isFirstClear = false
		local isNewStage = (clearedChapter > userStage.eventOpenChapter) or
			(clearedChapter == userStage.eventOpenChapter and clearedStage >= userStage.eventOpenStage)
		local isNotCleared = not userStage:IsEventStageCleared(clearedChapter, clearedStage)
		
		if isNewStage and isNotCleared then
			isFirstClear = true
		end
		
		-- 이벤트 스테이지 데이터에서 토큰 정보 가져오기
		local eventIdValue = tostring(_EventService.currentEventVersion)
		local eventStageData = _EventService:GetEventStageByIdFromServer(eventIdValue, clearedChapter, clearedStage)
		local eventToken = 0
		
		if isFirstClear then
			-- 최초 클리어 보상
			_BillingService:AddSecondFreeCoin(senderUserId, 300)
		
			-- 이벤트 토큰 지급 (최초 클리어)
			if eventStageData ~= nil and eventStageData.get_first_event_token ~= nil then
				eventToken = eventStageData.get_first_event_token
				_BillingService:AddEventToken(senderUserId, eventToken)
			end
		else
			-- 재클리어 보상: 이벤트 토큰 지급
			if eventStageData ~= nil and eventStageData.get_event_token ~= nil then
				eventToken = eventStageData.get_event_token
				_BillingService:AddEventToken(senderUserId, eventToken)
			end
		end
		
		-- 클라이언트 UI 업데이트 콜백 (이벤트 토큰 전달)
		self:StageClearClientCallback(isFirstClear, eventToken, senderUserId)
		
		userStage:AddClearedEventStage(clearedChapter, clearedStage)
		
		local nextStage = _EventService:GetNextOpenEventStageIdFromServer(userStage.eventOpenChapter, userStage.eventOpenStage)
		if nextStage.chapter ~= userStage.eventOpenChapter or nextStage.stage ~= userStage.eventOpenStage then
			userStage:SetClearEventStage(nextStage.chapter, nextStage.stage)
		end
	end

	@ExecSpace("Server")
	method void Log_EventStageClear()
		local playTime = DateTime.UtcNow.Elapsed - self.playStartTs
		local userEntity = _UserService:GetUserEntityByUserId(senderUserId)
		local selectStageId = self.mapIndex
		local userDeck = userEntity.UserDeck.userDeck
		local userSkill = userEntity.UserSkillDeck.userSkillDeck
		_AnalyticsService:GameEnd(senderUserId, playTime, selectStageId, userDeck, userSkill, true)
	end

	@ExecSpace("Client")
	method void StartTutorialGame()
		print("[Tutorial] StartTutorialGame called")
		
		-- MainLobbyUI 비활성화
		local mainLobbyUI = _EntityService:GetEntityByPath("/ui/MainLobbyUI")
		if mainLobbyUI ~= nil then
			mainLobbyUI.Enable = false
			mainLobbyUI.Visible = false
		end
		
		-- 돌파스킬 초기화 완료 후 프리로드 시작
		_UserService.LocalPlayer.UserBreakLimitSkillProtocol:InitCallWithCallback(function(limitBreakRuids)
			local ruids = self:GetPreLoadAssetRuid()
		
			-- 돌파스킬 ruids 추가
			for _, ruid in ipairs(limitBreakRuids) do
				table.insert(ruids, ruid)
			end
		
			_ResourceService:PreloadAsync(ruids, function()
				_TeleportService:TeleportToMapPosition(_UserService.LocalPlayer, Vector3.zero, "Stage000")
				self:GameStart(0, 0, false, false)
			end)
		end)
	end

	@ExecSpace("Server")
	method void Log_NormalStageClear()
		local playTime = DateTime.UtcNow.Elapsed - self.playStartTs
		local userEntity = _UserService:GetUserEntityByUserId(senderUserId)
		local selectStageId = self.chapterIndex * 100 + self.mapIndex
		local userDeck = userEntity.UserDeck.userDeck
		local userSkill = userEntity.UserSkillDeck.userSkillDeck
		_AnalyticsService:GameEnd(senderUserId, playTime, selectStageId, userDeck, userSkill, true)
	end

	@ExecSpace("Server")
	method void Log_NormalStageFail()
		local playTime = DateTime.UtcNow.Elapsed - self.playStartTs
		local userEntity = _UserService:GetUserEntityByUserId(senderUserId)
		local selectStageId = self.chapterIndex * 100 + self.mapIndex
		local userDeck = userEntity.UserDeck.userDeck
		local userSkill = userEntity.UserSkillDeck.userSkillDeck
		_AnalyticsService:GameEnd(senderUserId, playTime, selectStageId, userDeck, userSkill, false)
	end

	@ExecSpace("Server")
	method void Log_EventStageFail()
		local playTime = DateTime.UtcNow.Elapsed - self.playStartTs
		local userEntity = _UserService:GetUserEntityByUserId(senderUserId)
		local selectStageId = self.mapIndex
		local userDeck = userEntity.UserDeck.userDeck
		local userSkill = userEntity.UserSkillDeck.userSkillDeck
		_AnalyticsService:GameEnd(senderUserId, playTime, selectStageId, userDeck, userSkill, false)
	end

	@ExecSpace("Client")
	method void UpdateRankData(string userName, integer playTime, string key)
		self.rankUI:UpdateRankData(userName, playTime, key)
	end

	@ExecSpace("Client")
	method void SyncEventMode(boolean value)
		self.isEventMode = value
	end

	@EventSender("Service", "InputService")
	handler HandleKeyDownEvent(KeyDownEvent event)
		--------------- Native Event Sender Info ----------------
		-- Sender: InputService
		-- Space: Client
		---------------------------------------------------------
		
		-- Parameters
		local key = event.key
		---------------------------------------------------------
		-- if key == KeyboardKey.C and Environment:IsMakerPlay() then
		-- 	self:OpenSkillSelect()
		-- end
		
		if event.key == KeyboardKey.G and Environment:IsMakerPlay() then
			self:StageClear()
		end
		
		-- T키: 튜토리얼 데이터 리셋 (개발용)
		if event.key == KeyboardKey.T and Environment:IsMakerPlay() then
			_TutorialService:ResetTutorialData()
		end
	end

end