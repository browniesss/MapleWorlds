@Logic
script BillingService extends Logic

	@Sync
	property integer FirstFreeCoin = 0

	@Sync
	property integer FirstPaidCoin = 0

	@Sync
	property integer SecondFreeCoin = 0

	@Sync
	property integer SecondPaidCoin = 0

	@ExecSpace("ServerOnly")
	method integer SAVE(string uid)
		local ds = _DataStorageService:GetUserDataStorage(uid)
		
		local data = {}
		
		data["FirstFreeCoin"] = tostring(self.FirstFreeCoin)
		data["FirstPaidCoin"] = tostring(self.FirstPaidCoin)
		data["SecondFreeCoin"] = tostring(self.SecondFreeCoin)
		data["SecondPaidCoin"] = tostring(self.SecondPaidCoin)
		local save =  _HttpService:JSONEncode(data)
		
		return ds:SetAndWait("USER_COIN",save)
	end

	@ExecSpace("ServerOnly")
	method integer LOAD(string uid)
		local ds = _DataStorageService:GetUserDataStorage(uid)
		
		local errCode, res = ds:GetAndWait("USER_COIN")
		if errCode ~= 0 then
			return errCode
		end
		
		if res == nil then
			return 1000002
		end
		
		local resTable = _HttpService:JSONDecode(res)
		
		self.FirstFreeCoin = resTable["FirstFreeCoin"]
		self.FirstPaidCoin = resTable["FirstPaidCoin"]
		self.SecondFreeCoin = resTable["SecondFreeCoin"]
		self.SecondPaidCoin = resTable["SecondPaidCoin"]
		
		return 0
	end

	@ExecSpace("ServerOnly")
	method integer LOAD_OR_INIT(string uid)
		local errCode = self:LOAD(uid)
		
		if errCode == 1000002 then
			self.FirstFreeCoin = 3000
			self.FirstPaidCoin = 0
			self.SecondFreeCoin = 0
			self.SecondPaidCoin = 0
			
			return self:SAVE(uid)
		end
		
		if errCode > 0 then
			log_error(uid, "BILLING SERVICE FAIL TO GET OR CREATE, code: ", errCode)
			_UserService:KickUser(uid, KickReason.WorldError)
		end
		
		return 0
	end

	@ExecSpace("ServerOnly")
	method integer PurchaseFirstCoin(string userId, string productId)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local product = _ShopService.PRODUCT_ID_DICT[productId]
		if product == nil then
			return -1
		end
		
		for _, item in pairs(product.reward) do
			if item.type == "dia_paid" then
				self.FirstPaidCoin += item.value
			end
			
			if item.type == "dia_free" then
				self.FirstFreeCoin += item.value
			end
		end
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer PurchaseSecondCoin(string userId, string productId)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local product = _ShopService.PRODUCT_ID_DICT[productId]
		if product == nil then
			return -1
		end
		
		for _, item in pairs(product.reward) do
			if item.type == "coin" then
				self.SecondPaidCoin += item.value
			end
		end
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer ExchangeCoin(string userId, string productId)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local product = _ShopService.PRODUCT_ID_DICT[productId]
		if product == nil then
			return -1
		end
		
		for _, item in pairs(product.price) do
			if item.type == "dia" then
				local freeCoin = self.FirstFreeCoin
				local paidCoin = self.FirstPaidCoin
				local totalCoin = freeCoin + paidCoin
				if totalCoin < item.value then
					return -1
				end
				
				paidCoin -= item.value
				if paidCoin < 0 then
					freeCoin += paidCoin
					paidCoin = 0
				end
				
				self.FirstFreeCoin = freeCoin
				self.FirstPaidCoin = paidCoin
			end
		end
		
		for _, item in pairs(product.reward) do
			if item.type == "coin" then
				self.SecondPaidCoin += item.value
			end
		end
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer UseFirstCoin(string userId, integer usage)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local freeCoin = self.FirstFreeCoin
		local paidCoin = self.FirstPaidCoin
		local totalCoin = freeCoin + paidCoin
		if totalCoin < usage then
			return -1
		end
		
		paidCoin -= usage
		if paidCoin < 0 then
			freeCoin += paidCoin
			paidCoin = 0
		end
		
		self.FirstFreeCoin = freeCoin
		self.FirstPaidCoin = paidCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer UseSecondCoin(string userId, integer usage)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local freeCoin = self.SecondFreeCoin
		local paidCoin = self.SecondPaidCoin
		local totalCoin = freeCoin + paidCoin
		if totalCoin < usage then
			return -1
		end
		
		paidCoin -= usage
		if paidCoin < 0 then
			freeCoin += paidCoin
			paidCoin = 0
		end
		
		self.SecondFreeCoin = freeCoin
		self.SecondPaidCoin = paidCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddFirstFreeCoin(string userId, integer addCoin)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 11
		end
		
		self.FirstFreeCoin += addCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddSecondFreeCoin(string userId, integer addCoin)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 12
		end
		
		self.SecondFreeCoin += addCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("Server")
	method boolean Function1(string productID)
		local resultCode = _BillingService:ExchangeCoin(senderUserId, productID)
		local messagePopup = _EntityService:GetEntityByPath("/ui/ShopUI/ShopItemParent/MessagePopup")
		local isSuccess = false
		
		if resultCode == -1 then
			isSuccess = false
		else
			isSuccess = true	
		end
		
		messagePopup.MessagePopup:Init(isSuccess)
	end

	@ExecSpace("ServerOnly")
	@EventSender("Service", "UserService")
	handler HandleUserLeaveEvent(UserLeaveEvent event)
		--------------- Native Event Sender Info ----------------
		-- Sender: UserService
		-- Space: Server
		---------------------------------------------------------
		
		-- Parameters
		local ProfileCode = event.ProfileCode
		local UserId = event.UserId
		
		self:SAVE(UserId)
	end

end