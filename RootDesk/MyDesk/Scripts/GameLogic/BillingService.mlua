@Logic
script BillingService extends Logic

	@Sync
	property integer FirstFreeCoin = 0

	@Sync
	property integer FirstPaidCoin = 0

	@Sync
	property integer SecondFreeCoin = 0

	@Sync
	property integer SecondPaidCoin = 0

	@Sync
	property integer ThirdFreeCoin = 0

	@Sync
	property integer ThirdPaidCoin = 0

	@Sync
	property integer EventCoin = 0

	property table eventCoinCallbacks = {}

	@ExecSpace("ClientOnly")
	method void OnSyncProperty(string name, any value)
		if name == "EventCoin" then
			for _, callback in pairs(self.eventCoinCallbacks) do
				callback(value)
			end
		end
	end

	@ExecSpace("ClientOnly")
	method void AddEventCoinCallback(string key, any callback)
		self.eventCoinCallbacks[key] = callback
	end

	@ExecSpace("ClientOnly")
	method void RemoveEventCoinCallback(string key)
		self.eventCoinCallbacks[key] = nil
	end

	@ExecSpace("ServerOnly")
	method integer SAVE(string uid)
		local ds = _DataStorageService:GetUserDataStorage(uid)
		
		local data = {}
		
		data["FirstFreeCoin"] = tostring(self.FirstFreeCoin)
		data["FirstPaidCoin"] = tostring(self.FirstPaidCoin)
		data["SecondFreeCoin"] = tostring(self.SecondFreeCoin)
		data["SecondPaidCoin"] = tostring(self.SecondPaidCoin)
		data["ThirdFreeCoin"] = tostring(self.ThirdFreeCoin)
		data["ThirdPaidCoin"] = tostring(self.ThirdPaidCoin)
		local save =  _HttpService:JSONEncode(data)
		
		return ds:SetAndWait("USER_COIN",save)
	end

	@ExecSpace("ServerOnly")
	method integer LOAD(string uid)
		local ds = _DataStorageService:GetUserDataStorage(uid)
		
		local errCode, res = ds:GetAndWait("USER_COIN")
		if errCode ~= 0 then
			return errCode
		end
		
		if res == nil then
			return 1000002
		end
		
		local resTable = _HttpService:JSONDecode(res)
		
		self.FirstFreeCoin = resTable["FirstFreeCoin"]
		self.FirstPaidCoin = resTable["FirstPaidCoin"]
		self.SecondFreeCoin = resTable["SecondFreeCoin"]
		self.SecondPaidCoin = resTable["SecondPaidCoin"]
		self.ThirdFreeCoin = resTable["ThirdFreeCoin"] or 0
		self.ThirdPaidCoin = resTable["ThirdPaidCoin"] or 0
		
		return 0
	end

	@ExecSpace("ServerOnly")
	method integer LOAD_OR_INIT(string uid)
		local errCode = self:LOAD(uid)
		
		if errCode == 1000002 then
			self.FirstFreeCoin = 3000
			self.FirstPaidCoin = 0
			self.SecondFreeCoin = 0
			self.SecondPaidCoin = 0
			self.ThirdFreeCoin = 0
			self.ThirdPaidCoin = 0
		
			return self:SAVE(uid)
		end
		
		if errCode > 0 then
			log_error(uid, "BILLING SERVICE FAIL TO GET OR CREATE, code: ", errCode)
			_UserService:KickUser(uid, KickReason.WorldError)
		end
		
		if uid == "20372001292201301" or uid == "20372100004704052" or uid == "20372100008069853" then
			if self.FirstFreeCoin < 10000 then
				_BillingService:AddFirstFreeCoin(uid, 10000)
			end
		end
		
		return 0
	end

	@ExecSpace("ServerOnly")
	method integer PurchaseFirstCoin(string userId, string productId)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local product = _ShopService.PRODUCT_ID_DICT[productId]
		if product == nil then
			return -1
		end
		
		for _, item in pairs(product.reward) do
			if item.type == "dia_paid" then
				self.FirstPaidCoin += item.value
			end
			
			if item.type == "dia_free" then
				self.FirstFreeCoin += item.value
			end
		end
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer PurchaseSecondCoin(string userId, string productId)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local product = _ShopService.PRODUCT_ID_DICT[productId]
		if product == nil then
			return -1
		end
		
		for _, item in pairs(product.reward) do
			if item.type == "coin" then
				self.SecondPaidCoin += item.value
			end
		end
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer ExchangeCoin(string userId, string productId)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local product = _ShopService.PRODUCT_ID_DICT[productId]
		if product == nil then
			return -1
		end
		
		for _, item in pairs(product.price) do
			if item.type == "dia" then
				local freeCoin = self.FirstFreeCoin
				local paidCoin = self.FirstPaidCoin
				local totalCoin = freeCoin + paidCoin
				if totalCoin < item.value then
					return -1
				end
				
				paidCoin -= item.value
				if paidCoin < 0 then
					freeCoin += paidCoin
					paidCoin = 0
				end
				
				self.FirstFreeCoin = freeCoin
				self.FirstPaidCoin = paidCoin
			end
		end
		
		for _, item in pairs(product.reward) do
			if item.type == "coin" then
				self.SecondPaidCoin += item.value
			end
		end
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer UseFirstCoin(string userId, integer usage)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local freeCoin = self.FirstFreeCoin
		local paidCoin = self.FirstPaidCoin
		local totalCoin = freeCoin + paidCoin
		if totalCoin < usage then
			return -1
		end
		
		paidCoin -= usage
		if paidCoin < 0 then
			freeCoin += paidCoin
			paidCoin = 0
		end
		
		self.FirstFreeCoin = freeCoin
		self.FirstPaidCoin = paidCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer UseSecondCoin(string userId, integer usage)
		local loadErr =  self:LOAD(userId) 
		if loadErr ~= 0 then
			return loadErr
		end
		
		local freeCoin = self.SecondFreeCoin
		local paidCoin = self.SecondPaidCoin
		local totalCoin = freeCoin + paidCoin
		if totalCoin < usage then
			return -1
		end
		
		paidCoin -= usage
		if paidCoin < 0 then
			freeCoin += paidCoin
			paidCoin = 0
		end
		
		self.SecondFreeCoin = freeCoin
		self.SecondPaidCoin = paidCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddFirstFreeCoin(string userId, integer addCoin)
		local loadErr =  self:LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 11
		end
		
		self.FirstFreeCoin += addCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddFirstPaidCoin(string userId, integer addCoin)
		local loadErr = self:LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 14
		end
		
		self.FirstPaidCoin += addCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddSecondFreeCoin(string userId, integer addCoin)
		local loadErr =  self:LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 12
		end
		
		self.SecondFreeCoin += addCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddSecondPaidCoin(string userId, integer addCoin)
		local loadErr = self:LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 15
		end
		
		self.SecondPaidCoin += addCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer UseThirdCoin(string userId, integer usage)
		local loadErr = self:LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		local freeCoin = self.ThirdFreeCoin
		local paidCoin = self.ThirdPaidCoin
		local totalCoin = freeCoin + paidCoin
		if totalCoin < usage then
			return -1
		end
		
		paidCoin -= usage
		if paidCoin < 0 then
			freeCoin += paidCoin
			paidCoin = 0
		end
		
		self.ThirdFreeCoin = freeCoin
		self.ThirdPaidCoin = paidCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddThirdFreeCoin(string userId, integer addCoin)
		local loadErr = self:LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 13
		end
		
		self.ThirdFreeCoin += addCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddThirdPaidCoin(string userId, integer addCoin)
		local loadErr = self:LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 16
		end
		
		self.ThirdPaidCoin += addCoin
		
		return self:SAVE(userId)
	end

	@ExecSpace("Server")
	method boolean Function1(string productID)
		local resultCode = _BillingService:ExchangeCoin(senderUserId, productID)
		local messagePopup = _EntityService:GetEntityByPath("/ui/ShopUI/ShopItemParent/MessagePopup")
		local isSuccess = false
		
		if resultCode == -1 then
			isSuccess = false
		else
			isSuccess = true	
		end
		
		messagePopup.MessagePopup:Init(isSuccess)
	end

	@ExecSpace("ServerOnly")
	method integer EVENT_SAVE(string uid)
		local ds = _DataStorageService:GetUserDataStorage(uid)
		
		local data = {}
		
		data["EventCoin"] = self.EventCoin
		local save =  _HttpService:JSONEncode(data)
		
		local eventIndex = _EventService.currentEventId
		
		return ds:SetAndWait(eventIndex,save)
	end

	@ExecSpace("ServerOnly")
	method integer EVENT_LOAD(string uid)
		local ds = _DataStorageService:GetUserDataStorage(uid)
		
		local eventIndex = _EventService.currentEventId
		
		local errCode, res = ds:GetAndWait(eventIndex)
		if errCode ~= 0 then
			return errCode
		end
		
		if res == nil then
			return 1000002
		end
		
		local resTable = _HttpService:JSONDecode(res)
		
		self.EventCoin = resTable["EventCoin"]
		
		
		return 0
	end

	@ExecSpace("ServerOnly")
	method integer EVENT_LOAD_OR_INIT(string uid)
		local errCode = self:EVENT_LOAD(uid)
		
		if errCode == 1000002 then
			self.EventCoin = 0
			return self:EVENT_SAVE(uid)
		end
		
		if errCode > 0 then
			log_error(uid, "BILLING SERVICE EVENT FAIL TO GET OR CREATE, code: ", errCode)
		end
		
		return errCode
	end

	@ExecSpace("ServerOnly")
	method integer UseEventToken(string userId, integer usage)
		local loadErr = self:EVENT_LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		local eventCoin = self.EventCoin
		
		if eventCoin < usage then
			return -1
		end
		
		eventCoin -= usage
		
		self.EventCoin = eventCoin
		
		return self:EVENT_SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	method integer AddEventToken(string userId, integer addCoin)
		local loadErr = self:EVENT_LOAD(userId)
		if loadErr ~= 0 then
			return loadErr
		end
		
		if addCoin <= 0 then
			return 17
		end
		
		self.EventCoin += addCoin
		
		return self:EVENT_SAVE(userId)
	end

	@ExecSpace("ServerOnly")
	@EventSender("Service", "UserService")
	handler HandleUserLeaveEvent(UserLeaveEvent event)
		--------------- Native Event Sender Info ----------------
		-- Sender: UserService
		-- Space: Server
		---------------------------------------------------------
		
		-- Parameters
		local ProfileCode = event.ProfileCode
		local UserId = event.UserId
		
		self:SAVE(UserId)
		self:EVENT_SAVE(UserId)
	end

end