@Component
script MonsterSpawnService extends Component

	property table loopGroup = {}

	property table eventGroup = {}

	property table timerIdList = {}

	property number curTimeTs = 0

	property integer stageId = 0

	@ExecSpace("Server")
	method integer GroupSummon(table group)
		if group == nil then
			return
		end
		
		if #group == 0 then
			return
		end
		local value = group[1]
		_SpawnManager:SpawnEnemy(value.unit, Vector3.zero)
		
		table.remove(group, 1)
		
		self.timerIdList[#self.timerIdList + 1] = _TimerService:SetTimerOnce(
			function() self:GroupSummon(group) end,
			value.delayTs
		)
	end

	method void OnDamage()
		-- EVENT DAMAGED 시 호출되는 함수
		local damageList = self.eventGroup['DAMAGED']
		
		for i, g in ipairs(damageList) do
			if g.count >= g.maxCount then
				continue
			end
			
			local delayEndTs = g.lastTs + g.delayTs
			if self.curTimeTs < delayEndTs then
				continue
			end
			
			g.lastTs = self.curTimeTs
			g.count = g.count + 1
			
			
			local groupTable = {}
			for i, g in ipairs(g.group) do
				local value = {}
				value['unit'] = g.unit
				value['delayTs'] = g.delayTs
				
				table.insert(groupTable, value)
			end
		
			self.timerIdList[#self.timerIdList + 1] = _TimerService:SetTimerOnce(
				function() self:GroupSummon(groupTable) end,
				0
			)
		end
	end

	method void LoopGroupSummon(number group)
		local group_data
		if _GameManager.isEventMode then
			group_data = _eventGroupRepo:GetGroupById(group)
		else
			group_data = _groupRepo:GetGroupById(group)
		end

		local groupTable = {}
		for i, g in ipairs(group_data) do
			local value = {}
			value['unit'] = g.unit
			value['delayTs'] = g.delayTs

			table.insert(groupTable, value)
		end

		self.timerIdList[#self.timerIdList + 1] = _TimerService:SetTimerOnce(
			function() self:GroupSummon(groupTable) end,
			0
		)
	end

	@ExecSpace("ClientOnly")
	method void OnEndPlay()
		for i, id in ipairs(self.timerIdList) do
			_TimerService:ClearTimer(id)
		end
	end

	@ExecSpace("ClientOnly")
	method void OnMapEnter(Entity enteredMap)
		local isStageMap = string.find(enteredMap.Name, "Stage") ~= nil
		local isEventMap = string.find(enteredMap.Name, "Event") ~= nil

		if not isStageMap and not isEventMap then
			return
		end

		if enteredMap.Name == "Stage000" then
			return
		end

		for i, id in ipairs(self.timerIdList) do
			_TimerService:ClearTimer(id)
		end

		self.loopGroup = {}
		self.eventGroup = {}
		self.timerIdList = {}
		self.curTimeTs = 0

		self:InitServer()

		if _GameManager.isEventMode then
			local userEventStage = _UserService.LocalPlayer.UserEventStage
			self:SetStage(userEventStage.selectChapter, userEventStage.selectStage)
		else
			local userStage = _UserService.LocalPlayer.UserStage
			self:SetStage(userStage.selectChapter, userStage.selectStage)
		end
	end

	method void SetStage(integer targetChapter, integer targetStage)
		local target
		if _GameManager.isEventMode then
			target = tostring(targetStage)
		else
			target = tostring(targetStage + 100 * targetChapter)
		end

		local settingFunction = function()
			local patterns
			if _GameManager.isEventMode then
				patterns = _eventPatternRepo:GetPatternByStage(target)
			else
				patterns = _patternRepo:GetPatternByStage(target)
			end

			self.curTimeTs = 0

			if patterns == nil then
				return
			end

			for i, pattern in ipairs(patterns) do
				if pattern.type == 'LOOP' then
					local setting = _settingRepo:GetSettingByTypeAndId('LOOP', pattern.setting)

					local id = _TimerService:SetTimerRepeat(
						function()
							self:LoopGroupSummon(pattern.group)
						end,
						setting.delayTs,
						setting.startTs)
					self.timerIdList[#self.timerIdList + 1] = id
					self.timerIdList[#self.timerIdList + 1] = _TimerService:SetTimerOnce(
						function()
							_TimerService:ClearTimer(id)
						end,
						setting.endTs)
				end

				if pattern.type == 'EVENT' then
					local setting = _settingRepo:GetSettingByTypeAndId('EVENT', pattern.setting)
					local group_data
					if _GameManager.isEventMode then
						group_data = _eventGroupRepo:GetGroupById(pattern.group)
					else
						group_data = _groupRepo:GetGroupById(pattern.group)
					end

					if self.eventGroup[setting.type] == nil then
						self.eventGroup[setting.type] = {}
					end

					local id = #self.eventGroup[setting.type] + 1

					local item = {}
					item['count'] = 0
					item['delayTs'] = setting.delayTs
					item['maxCount'] = setting.count
					item['lastTs'] = -1
					item['group'] = {}

					self.eventGroup[setting.type][id] = item

					for i, g in ipairs(group_data) do
						table.insert(self.eventGroup[setting.type][id].group, g)
					end
				end
			end
		end
		
		_TimerService:SetTimerOnce(settingFunction, 1)
	end

	@ExecSpace("ClientOnly")
	method void OnMapLeave(Entity leftMap)
		for i, id in ipairs(self.timerIdList) do
			_TimerService:ClearTimer(id)
		end

		self.loopGroup = {}
		self.eventGroup = {}
		self.timerIdList = {}
		self.curTimeTs = 0

		self:InitServer()
	end

	@ExecSpace("Server")
	method void InitServer()
		if senderUserId == nil then
			return
		end

		local user = _UserService:GetUserEntityByUserId(senderUserId)

		if _GameManager.isEventMode then
			local userEventStage = user.UserEventStage
			self.stageId = userEventStage.selectStage
		else
			local userStage = user.UserStage
			self.stageId = userStage.selectChapter * 100 + userStage.selectStage
		end

		for i, id in ipairs(self.timerIdList) do
			_TimerService:ClearTimer(id)
		end

		self.loopGroup = {}
		self.eventGroup = {}
		self.timerIdList = {}
		self.curTimeTs = 0
	end

end