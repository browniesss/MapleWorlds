@Logic
script BadgeConditionService extends Logic

	property table conditions = {}

	@ExecSpace("ServerOnly")
	method void OnBeginPlay()
		self:LoadBadgeConditions()
	end

	@ExecSpace("ServerOnly")
	method void LoadBadgeConditions()
		local dataSet = _DataService:GetTable("BadgeConditions")

		if dataSet == nil then
			return
		end

		local count = dataSet:GetRowCount()

		for i = 1, count do
			local condition = {}
			condition["id"] = tonumber(dataSet:GetCell(i, "id"))
			condition["badge_id"] = tostring(dataSet:GetCell(i, "badge_id"))
			condition["type"] = tostring(dataSet:GetCell(i, "type"))
			condition["grade"] = tostring(dataSet:GetCell(i, "grade"))
			condition["name"] = tostring(dataSet:GetCell(i, "name"))
			condition["description"] = tostring(dataSet:GetCell(i, "description"))
			condition["thumbnail_ruid"] = tostring(dataSet:GetCell(i, "thumbnail_ruid"))

			local chapterStr = tostring(dataSet:GetCell(i, "chapter"))
			local stageStr = tostring(dataSet:GetCell(i, "stage"))
			local rankStr = tostring(dataSet:GetCell(i, "rank"))

			condition["chapter"] = (chapterStr ~= "-" and chapterStr ~= "") and tonumber(chapterStr) or nil
			condition["stage"] = (stageStr ~= "-" and stageStr ~= "") and tonumber(stageStr) or nil
			condition["unit_id"] = tostring(dataSet:GetCell(i, "unit_id"))
			condition["rank"] = (rankStr ~= "-" and rankStr ~= "") and tonumber(rankStr) or nil
			condition["enabled"] = tostring(dataSet:GetCell(i, "enabled")) == "TRUE"
			condition["reward_type"] = tostring(dataSet:GetCell(i, "reward_type"))
			condition["reward_amount"] = tonumber(dataSet:GetCell(i, "reward_amount"))

			self.conditions[condition.badge_id] = condition
		end
	end

	@ExecSpace("Server")
	method void CheckAndAwardBadge(string userId, string badgeId)
		local condition = self.conditions[badgeId]
		if condition == nil then
			return
		end

		if not condition.enabled then
			return
		end

		local hasBadge = self:IsBadgeAcquired(userId, badgeId)
		if hasBadge then
			return
		end

		local passed = false
		if condition.type == "CHAPTER_CLEAR" then
			passed = self:CheckChapterClear(userId, condition)
		elseif condition.type == "PICKUP_CHAR" then
			passed = self:CheckPickupChar(userId, condition)
		elseif condition.type == "NPC" then
			-- NPC 타입은 BadgeNpc에서 직접 호출하므로 바로 통과
			passed = true
		end

		if passed then
			local success = _BadgeService:AwardBadgeAndWait(userId, badgeId)

			if Environment:IsMakerPlay() then
				-- Maker 환경에서는 BadgeService가 영구 저장 안되므로 DataStorage에 백업 저장
				self:SetBadgeAcquired(userId, badgeId)
			end

			-- 배지 획득 시 레드닷 상태 갱신
			local hasUnclaimed = self:HasUnclaimedRewards(userId)
			_BadgeUIService:SendRedDotStatus(userId, hasUnclaimed)
		end
	end

	@ExecSpace("Server")
	method boolean CheckChapterClear(string userId, table condition)
		-- CheckChapterBadges에서 이미 클리어한 챕터 번호로 필터링해서 호출하므로 바로 true 반환
		return true
	end

	@ExecSpace("Server")
	method boolean CheckPickupChar(string userId, table condition)
		-- CheckPickupBadges already filtered by matching unitId, so always return true here
		return true
	end

	@ExecSpace("Server")
	method void CheckChapterBadges(string userId, integer chapter)
		local count = 0
		for badgeId, condition in pairs(self.conditions) do
			if condition.enabled and
			   condition.type == "CHAPTER_CLEAR" and
			   condition.chapter == chapter then
				self:CheckAndAwardBadge(userId, badgeId)
				count = count + 1
			end
		end
	end

	@ExecSpace("Server")
	method void CheckStageBadges(string userId, integer chapter, integer stage)
		-- 현재 스테이지별 랭킹 배지는 사용하지 않음
	end

	@ExecSpace("Server")
	method void CheckPickupBadges(string userId, string unitId)
		for badgeId, condition in pairs(self.conditions) do
			if condition.enabled and
			   condition.type == "PICKUP_CHAR" and
			   condition.unit_id == unitId then
				self:CheckAndAwardBadge(userId, badgeId)
			end
		end
	end

	@ExecSpace("Server")
	method void CheckAllBadges(string userId)
		for badgeId, condition in pairs(self.conditions) do
			if condition.enabled then
				self:CheckAndAwardBadge(userId, badgeId)
			end
		end
	end

	@ExecSpace("Server")
	method table GetAllBadgeConditions()
		return self.conditions
	end

	@ExecSpace("Server")
	method table GetUserBadgeStatus(string userId)
		local badgeStatus = {}

		for badgeId, condition in pairs(self.conditions) do
			if condition.enabled then
				local hasBadge = self:IsBadgeAcquired(userId, badgeId)
				local claimed = self:IsRewardClaimed(userId, badgeId)

				badgeStatus[badgeId] = {
					acquired = hasBadge,
					claimed = claimed,
					condition = condition
				}
			end
		end

		return badgeStatus
	end

	@ExecSpace("Server")
	method boolean IsRewardClaimed(string userId, string badgeId)
		local ds = _DataStorageService:GetUserDataStorage(userId)
		local errorCode, claimed = ds:GetAndWait("BADGE_REWARD_" .. badgeId)

		if errorCode == 0 and claimed == "true" then
			return true
		end

		return false
	end

	@ExecSpace("Server")
	method void SetRewardClaimed(string userId, string badgeId)
		local ds = _DataStorageService:GetUserDataStorage(userId)
		ds:SetAndWait("BADGE_REWARD_" .. badgeId, "true")
	end

	@ExecSpace("Server")
	method boolean IsBadgeAcquired(string userId, string badgeId)
		if Environment:IsMakerPlay() then
			-- Maker 환경에서는 DataStorage 확인
			local ds = _DataStorageService:GetUserDataStorage(userId)
			local errorCode, acquired = ds:GetAndWait("BADGE_ACQUIRED_" .. badgeId)

			if errorCode == 0 and acquired == "true" then
				return true
			end
			return false
		end

		-- 라이브 환경에서는 네이티브 BadgeService만 확인
		local hasBadge = _BadgeService:UserHasBadgeAndWait(userId, badgeId)
		return hasBadge
	end

	@ExecSpace("Server")
	method void SetBadgeAcquired(string userId, string badgeId)
		-- Maker 환경에서만 DataStorage에 저장
		if not Environment:IsMakerPlay() then
			return
		end

		local ds = _DataStorageService:GetUserDataStorage(userId)
		ds:SetAndWait("BADGE_ACQUIRED_" .. badgeId, "true")
	end

	@ExecSpace("Server")
	method boolean ClaimBadgeReward(string userId, string badgeId)
		local condition = self.conditions[badgeId]
		if condition == nil then
			return false
		end

		local hasBadge = self:IsBadgeAcquired(userId, badgeId)
		if not hasBadge then
			return false
		end

		local claimed = self:IsRewardClaimed(userId, badgeId)
		if claimed then
			return false
		end

		if condition.reward_type == "FirstCoin" then
			_BillingService:AddFirstFreeCoin(userId, condition.reward_amount)
		elseif condition.reward_type == "SecondCoin" then
			_BillingService:AddSecondFreeCoin(userId, condition.reward_amount)
		elseif condition.reward_type == "ThirdCoin" then
			_BillingService:AddThirdFreeCoin(userId, condition.reward_amount)
		end

		self:SetRewardClaimed(userId, badgeId)

		return true
	end

	@ExecSpace("Server")
	method boolean HasUnclaimedRewards(string userId)
		for badgeId, condition in pairs(self.conditions) do
			if condition.enabled then
				local hasBadge = self:IsBadgeAcquired(userId, badgeId)
				local claimed = self:IsRewardClaimed(userId, badgeId)

				if hasBadge and not claimed then
					return true
				end
			end
		end

		return false
	end

	@ExecSpace("Server")
	method void CheckAllBadgesOnLogin(string userId)
		-- 1. 챕터 클리어 배지 체크 (모든 클리어한 챕터)
		local player = _UserService:GetUserEntityByUserId(userId)
		if player ~= nil and player.UserStage ~= nil then
			local openChapter = player.UserStage.openChapter
			-- openChapter는 현재 진행 가능한 챕터이므로 openChapter-1까지가 클리어한 챕터
			for chapter = 1, openChapter - 1 do
				self:CheckChapterBadges(userId, chapter)
			end
		end

		-- 2. 픽업 캐릭터 배지 체크 (보유한 모든 캐릭터)
		-- _UserMonsterService:GetList()는 ClientOnly이므로 userMonsterDict 직접 순회
		for unitId, json in pairs(_UserMonsterService.userMonsterDict) do
			self:CheckPickupBadges(userId, unitId)
		end
	end

end
