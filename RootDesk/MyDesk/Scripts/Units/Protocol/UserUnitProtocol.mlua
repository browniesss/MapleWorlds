@Component
script UserUnitProtocol extends CommonProtocol

	@ExecSpace("Server")
	method void GetUserUnitListCall()
		self:CommonCall(senderUserId)
		
		_UserMonsterService:INIT(senderUserId)
		local userMonsterData = _UserMonsterService.userMonsterDict
		local unitData = _UnitService:GetUnitAll()
		
		local resp = {}
		
		for id, json in pairs(userMonsterData) do
			local userUnitModel = UserUnitModel()
			userUnitModel:DECODE(json)
			
			log(id, "-", json)
			local buffedUnit = BuffedUnitModel()
			buffedUnit:Init(unitData[id])
			
			resp[id] = _BuffedUnitService:SetUnitBuff(buffedUnit, userUnitModel.level, userUnitModel.limitBreak)
		end
		
		_UnitLevelUpRepo:SyncData(_UnitLevelUpRepo.dataMap, senderUserId)
		_UnitLimitBreakRepo:SyncData(_UnitLimitBreakRepo.dataMap, senderUserId)
		self:GetUserUnitListBack(resp, senderUserId)
	end

	@ExecSpace("Client")
	method void GetUserUnitListBack(table resp)
		for id, data in pairs(resp) do
			self.Entity.UserUnitStore:UpdateDictByKey(id, data)
		end
		self.Entity.UserUnitStore:UpdateDoneCallback()
	end

	@ExecSpace("Server")
	method void LevelUpUserUnitCall(string id)
		self:CommonCall(senderUserId)
		
		local unitData = _UnitService:GetUnitAll()
		local userMonsterData = _UserMonsterService.userMonsterDict
		
		local userUnitModel = UserUnitModel()
		userUnitModel:DECODE(userMonsterData[id])
		
		local buffedUnit = BuffedUnitModel()
		buffedUnit:Init(unitData[id])
		
		if userUnitModel.level >= _UnitLevelUpRepo.UserMaxLevel then
			log(senderUserId," max user level ", id)
			return
		end
		
		local nextLevel = userUnitModel.level + 1
		local nextLevelData = _UnitLevelUpRepo:GetBuff(buffedUnit.jobId, buffedUnit.grade, nextLevel)
		if nextLevelData == nil or nextLevelData.level == 0 then
			log(senderUserId," max data level ", id)
			return
		end
		
		local totalCoin = _BillingService.ThirdFreeCoin + _BillingService.ThirdPaidCoin
		if totalCoin < nextLevelData.price then
			self:LogAndKick(senderUserId, "not enough coin")
			return
		end
		
		local billingCode = _BillingService:UseThirdCoin(senderUserId, nextLevelData.price)
		if not (billingCode == 0) then
			self:LogAndKick(senderUserId, "fail to use thrid coin, code: " .. billingCode)
			return
		end
		
		local updateList = {}
		updateList[1] = id
		local saveResult = _UserMonsterService:LEVEL_UP(senderUserId, updateList)
		if not (saveResult.code == 0) then
			self:LogAndKick(senderUserId, "fail to level up, code: " .. saveResult.code)
			return
		end
		
		userMonsterData = _UserMonsterService.userMonsterDict
		userUnitModel:DECODE(userMonsterData[id])
		buffedUnit:Init(unitData[id])
		
		self:LevelUpUnitBack(_BuffedUnitService:SetUnitBuff(buffedUnit, userUnitModel.level, userUnitModel.limitBreak))
	end

	@ExecSpace("Client")
	method void LevelUpUnitBack(BuffedUnitModel data)
		self.Entity.UserUnitStore:UpdateDictByKey(data.id, data)
		self.Entity.UserUnitStore:UpdateDoneCallback()
	end

	@ExecSpace("Server")
	method void BreakLimitUnitCall(string id)
		self:CommonCall(senderUserId)
		
		local unitData = _UnitService:GetUnitAll()
		local userMonsterData = _UserMonsterService.userMonsterDict
		
		local userUnitModel = UserUnitModel()
		userUnitModel:DECODE(userMonsterData[id])
		
		local buffedUnit = BuffedUnitModel()
		buffedUnit:Init(unitData[id])
		
		if userUnitModel.limitBreak >= _UnitLimitBreakRepo.UserMaxLevel then
			log(senderUserId," max user limit break ", id)
			return
		end
		
		local nextLimitBreak = userUnitModel.limitBreak + 1
		local nextData = _UnitLimitBreakRepo:GetBuff(buffedUnit.grade, nextLimitBreak, buffedUnit.id)
		if nextData == nil or nextData.limitBreak == 0 then
			log(senderUserId," max data limit break ", id)
			return
		end
		
		if userUnitModel.count <= userUnitModel.limitBreak then
			self:LogAndKick(senderUserId, "not enough count")
			return
		end
		
		local updateList = {}
		updateList[1] = id
		local saveResult = _UserMonsterService:LIMIT_BREAK(senderUserId, updateList)
		if not (saveResult.code == 0) then
			self:LogAndKick(senderUserId, "fail to level up, code: " .. saveResult.code)
			return
		end
		
		userMonsterData = _UserMonsterService.userMonsterDict
		userUnitModel:DECODE(userMonsterData[id])
		buffedUnit:Init(unitData[id])
		
		self:BreakLimitUnitBack(_BuffedUnitService:SetUnitBuff(buffedUnit, userUnitModel.level, userUnitModel.limitBreak))
	end

	@ExecSpace("Client")
	method void BreakLimitUnitBack(BuffedUnitModel data)
		self.Entity.UserUnitStore:UpdateDictByKey(data.id, data)
		self.Entity.UserUnitStore:UpdateDoneCallback()
	end

	@ExecSpace("ServerOnly")
	method void UpdateUserUnitList(string uid)
		local userMonsterData = _UserMonsterService.userMonsterDict
		local unitData = _UnitService:GetUnitAll()
		
		local resp = {}
		
		for id, json in pairs(userMonsterData) do
			local userUnitModel = UserUnitModel()
			userUnitModel:DECODE(json)
			
			log(id, "-", json)
			local buffedUnit = BuffedUnitModel()
			buffedUnit:Init(unitData[id])
			
			resp[id] = _BuffedUnitService:SetUnitBuff(buffedUnit, userUnitModel.level, userUnitModel.limitBreak)
		end
		
		_UnitLevelUpRepo:SyncData(_UnitLevelUpRepo.dataMap, uid)
		_UnitLimitBreakRepo:SyncData(_UnitLimitBreakRepo.dataMap, uid)
		self:GetUserUnitListBack(resp, uid)
	end

end