@Logic
script MatrixUnitSelectService extends Logic

	property Entity matrixSelectUI = nil

	property Entity unitSelectUI = nil

	property Entity charterViewList = nil

	property Entity augmentPanel = nil

	property integer remainingSelections = 0

	property table currentChoiceIds = {}

	property boolean isSelectingUnit = false

	property any onSelectionCompleteCallback = nil

	-- 유닛 강화 모드 관련 프로퍼티
	property boolean isUpgradeMode = false
	-- currentUpgradeChoices 구조: { {unitId, buffType, buffValue}, ... }
	property table currentUpgradeChoices = {}

	-- 서버용: 유닛별 중복 강화 누적 데이터 {unitId -> {damage=N, hp=N}}
	property table unitUpgrades = {}

	-- 초기 덱 기반 선택 모드 (유저 덱 8개에서 선택)
	property boolean isInitialDeckSelection = false

	-- 보너스 픽업 모드 (초기 덱 선택 시에만 활성화)
	property boolean isBonusPickupMode = false
	-- currentChoiceIds에서 보너스 캐릭터 인덱스 추적 (true = bonus)
	property table bonusChoiceFlags = {}

	-- 중복 선택 강화 보너스 값 (MatrixCoinConfig에서 로드)
	property number overlapDamageBonus = 5
	property number overlapHPBonus = 50

	@ExecSpace("ClientOnly")
	method void OnBeginPlay()
		self.matrixSelectUI = _EntityService:GetEntityByPath("/ui/MatrixUI/MatrixSelectUI")
		self.unitSelectUI = _EntityService:GetEntityByPath("/ui/MatrixUI/MatrixSelectUI/UnitSelectUI")
		self.charterViewList = _EntityService:GetEntityByPath("/ui/MatrixUI/MatrixSelectUI/UnitSelectUI/CharterViewList_1")
		self.augmentPanel = _EntityService:GetEntityByPath("/ui/MatrixUI/MatrixSelectUI/MatrixSelectUI")
		self:LoadOverlapConfig()
	end

	@ExecSpace("ClientOnly")
	method void LoadOverlapConfig()
		local dataSet = _DataService:GetTable("MatrixCoinConfig")
		if dataSet == nil then
			return
		end

		if dataSet:GetRowCount() < 1 then
			return
		end

		self.overlapDamageBonus = tonumber(dataSet:GetCell(1, "overlapDamageBonus")) or 5
		self.overlapHPBonus = tonumber(dataSet:GetCell(1, "overlapHPBonus")) or 50
	end

	@ExecSpace("Client")
	method void StartUnitSelection(integer count, any callback)
		self.remainingSelections = count
		self.onSelectionCompleteCallback = callback
		self:ShowUnitSelectionUI()
	end

	@ExecSpace("Client")
	method void ShowUnitSelectionUI()
		local user = _UserService.LocalPlayer
		if user == nil or user.UserMatrixManager == nil then
			return
		end

		-- 8개 유닛 보유 시 강화 모드로 전환
		if user.UserMatrixManager:IsUnitListFull() then
			self:ShowUnitUpgradeUI()
			return
		end

		self.isSelectingUnit = true
		self.isUpgradeMode = false
		self.bonusChoiceFlags = {}

		-- 초기 덱 선택 모드이면 유저 덱에서, 아니면 전체 풀에서 랜덤 생성
		local choices
		if self.isInitialDeckSelection then
			choices = self:GenerateDeckUnitChoices()
		else
			choices = self:GenerateUnitChoices()
		end
		if choices == nil or #choices == 0 then
			self.isSelectingUnit = false
			if self.onSelectionCompleteCallback ~= nil then
				self.onSelectionCompleteCallback()
				self.onSelectionCompleteCallback = nil
			end
			return
		end

		self.currentChoiceIds = choices

		-- 게임 일시정지
		if _MatrixGameManager ~= nil then
			_MatrixGameManager:PauseGame()
		end

		-- 서버측 일시정지 (MesoIncome 연동)
		if _MatrixService ~= nil then
			_MatrixService:SetGamePausedOnServer(true)
		end

		-- MatrixSelectUI 컨테이너 활성화
		if self.matrixSelectUI ~= nil then
			self.matrixSelectUI.Enable = true
			self.matrixSelectUI.Visible = true
		end

		-- UnitSelectUI 활성화, 증강 패널 비활성화
		if self.unitSelectUI ~= nil then
			self.unitSelectUI.Enable = true
			self.unitSelectUI.Visible = true
		end
		if self.augmentPanel ~= nil then
			self.augmentPanel.Enable = false
		end

		-- CharterView에 유닛 데이터 표시
		self:PopulateCharterViews(choices)
	end

	method void PopulateCharterViews(table choiceIds)
		if self.charterViewList == nil then
			return
		end

		local user = _UserService.LocalPlayer
		if user == nil or user.UserMatrixManager == nil then
			return
		end

		local unitPool = user.UserMatrixManager.unitPool
		local bonusPool = user.UserMatrixManager.bonusPool
		local children = self.charterViewList.Children
		local index = 1

		for _, child in pairs(children) do
			if child.CharterView ~= nil then
				if index > #choiceIds then
					child.CharterView.Entity.Enable = false
				else
					child.CharterView.Entity.Enable = true
					local unitId = choiceIds[index]

					-- 보너스 픽업 캐릭터 여부 확인
					local isBonus = self.bonusChoiceFlags[index] or false

					local unitData = nil
					if isBonus then
						unitData = bonusPool[unitId]
					else
						unitData = unitPool[unitId]
					end

					if isBonus and unitData ~= nil then
						child.CharterView:InitBonusPickup(unitData)
					else
						child.CharterView:InitGacha(unitData)
					end
				end
				index = index + 1
			end
		end
	end

	method table GenerateUnitChoices()
		local user = _UserService.LocalPlayer
		if user == nil or user.UserMatrixManager == nil then
			return {}
		end

		local matrixManager = user.UserMatrixManager
		local pool = matrixManager.unitPool
		local unitList = matrixManager.unitList
		local subUnitList = matrixManager.subUnitList or {}

		-- subUnitList를 빠른 조회용 테이블로 변환
		local subUnitSet = {}
		for _, unitId in ipairs(subUnitList) do
			subUnitSet[unitId] = true
		end

		-- 선택 가능 목록 구성 (이미 선택한 유닛 및 서브 유닛 제외)
		local available = {}
		for unitId, unitData in pairs(pool) do
			if unitList[unitId] == nil and subUnitSet[unitId] == nil then
				table.insert(available, unitId)
			end
		end


		-- Fisher-Yates 셔플
		for i = #available, 2, -1 do
			local j = math.random(1, i)
			available[i], available[j] = available[j], available[i]
		end

		-- 최대 4개 선택
		local choices = {}
		for i = 1, math.min(4, #available) do
			table.insert(choices, available[i])
		end

		return choices
	end

	-- 유저 덱(8개)에서 아직 선택하지 않은 유닛 중 랜덤 선택 + 보너스 픽업 캐릭터
	method table GenerateDeckUnitChoices()
		local user = _UserService.LocalPlayer
		if user == nil then
			return {}
		end

		local userDeck = user.UserDeck
		if userDeck == nil then
			return {}
		end

		local matrixManager = user.UserMatrixManager
		if matrixManager == nil then
			return {}
		end

		local unitList = matrixManager.unitList

		-- 덱에서 아직 선택하지 않은 유닛만 추출 (보너스 픽업 캐릭터 제외)
		local bonusPool = matrixManager.bonusPool
		local available = {}
		for i = 1, 8 do
			local unitId = userDeck.userDeck[i]
			if unitId ~= nil and unitList[unitId] == nil and bonusPool[unitId] == nil then
				table.insert(available, unitId)
			end
		end

		-- Fisher-Yates 셔플
		for i = #available, 2, -1 do
			local j = math.random(1, i)
			available[i], available[j] = available[j], available[i]
		end

		-- 보너스 캐릭터 수집
		local bonusIds = {}
		for bonusId, _ in pairs(matrixManager.bonusPool) do
			table.insert(bonusIds, bonusId)
		end

		-- 보너스 캐릭터 수에 따라 덱 유닛 수 결정 (총 4개 유지)
		local bonusCount = math.min(#bonusIds, 2)
		local deckCount = math.min(4 - bonusCount, #available)

		local choices = {}
		self.bonusChoiceFlags = {}

		-- 덱 유닛 추가
		for i = 1, deckCount do
			table.insert(choices, available[i])
			self.bonusChoiceFlags[#choices] = false
		end

		-- 보너스 캐릭터 추가
		for i = 1, bonusCount do
			table.insert(choices, bonusIds[i])
			self.bonusChoiceFlags[#choices] = true
		end

		-- 보너스 캐릭터가 있으면 모드 활성화
		self.isBonusPickupMode = (bonusCount > 0)

		return choices
	end

	@ExecSpace("Client")
	method void SelectUnitByIndex(integer index)
		if not self.isSelectingUnit then
			return
		end

		local unitId = self.currentChoiceIds[index]
		if unitId == nil then
			return
		end

		self.isSelectingUnit = false

		local user = _UserService.LocalPlayer
		if user ~= nil and user.UserMatrixManager ~= nil then
			local matrixManager = user.UserMatrixManager
			local isBonus = self.bonusChoiceFlags[index] or false

			local unitData = nil
			if isBonus then
				-- 보너스 풀에서 가져와서 unitPool에 추가
				unitData = matrixManager.bonusPool[unitId]
				if unitData ~= nil then
					matrixManager:AddUnitToPool(unitId, unitData)
				end
			else
				unitData = matrixManager.unitPool[unitId]
			end

			matrixManager:AddUnitToList(unitId, unitData)
		end

		-- 보너스 모드 해제 및 bonusPool 정리 (선택되지 않은 보너스 캐릭터 제거)
		if self.isBonusPickupMode then
			self.isBonusPickupMode = false
			if user ~= nil and user.UserMatrixManager ~= nil then
				user.UserMatrixManager.bonusPool = {}
			end
		end

		-- MatrixExtendUnitShop에 유닛 추가
		if _MatrixGameManager ~= nil and _MatrixGameManager.unitShop ~= nil then
			local shop = _MatrixGameManager.unitShop.MatrixExtendUnitShop
			if shop ~= nil then
				shop:AddUnit(unitId)
			end
		end

		-- 시너지 카운트 업데이트 (서버로 전송)
		if user ~= nil and user.UserSynergyComponent ~= nil then
			user.UserSynergyComponent:AddCountFromClient(unitId)
		end

		-- 메소 UI 업데이트 (시너지 변경 반영)
		self:RefreshMesoIncomeUI()

		-- 매트릭스 돌파 스킬 갱신 (유닛 추가 시마다 돌파 스킬 목록 업데이트)
		if user ~= nil and user.UserBreakLimitSkillProtocol ~= nil then
			user.UserBreakLimitSkillProtocol:MatrixInitCallWithCallback(function(limitBreakRuids)
				if limitBreakRuids ~= nil and #limitBreakRuids > 0 then
					_ResourceService:PreloadAsync(limitBreakRuids, function() end)
				end
			end)
		end

		-- UI 닫기
		self:CloseUnitSelectionUI()

		-- 남은 선택 처리
		self.remainingSelections = self.remainingSelections - 1

		if self.remainingSelections > 0 then
			-- 다음 선택 (0.5초 딜레이)
			_TimerService:SetTimerOnce(function()
				self:ShowUnitSelectionUI()
			end, 0.5)
		else
			-- 초기 덱 선택 모드 해제
			self.isInitialDeckSelection = false

			-- 선택 완료 → 콜백 호출
			if self.onSelectionCompleteCallback ~= nil then
				local callback = self.onSelectionCompleteCallback
				self.onSelectionCompleteCallback = nil
				callback()
			end
		end
	end

	@ExecSpace("Client")
	method void CloseUnitSelectionUI()
		if self.unitSelectUI ~= nil then
			self.unitSelectUI.Enable = false
		end
		
		if self.matrixSelectUI ~= nil then
			self.matrixSelectUI.Enable = false
			self.matrixSelectUI.Visible = false
		end
		
		-- 게임 재개
		if _MatrixGameManager ~= nil then
			_MatrixGameManager:ResumeGame()
		end
		
		-- 서버측 일시정지 해제 (MesoIncome 연동)
		if _MatrixService ~= nil then
			_MatrixService:SetGamePausedOnServer(false)
		end
	end

	method void Reset()
		self.remainingSelections = 0
		self.currentChoiceIds = {}
		self.isSelectingUnit = false
		self.isUpgradeMode = false
		self.isInitialDeckSelection = false
		self.currentUpgradeChoices = {}
		self.onSelectionCompleteCallback = nil
		self.unitUpgrades = {}
		self.isBonusPickupMode = false
		self.bonusChoiceFlags = {}
	end

	-- ============================================
	-- 유닛 강화 모드 (8개 유닛 보유 시)
	-- ============================================

	@ExecSpace("Client")
	method void ShowUnitUpgradeUI()
		self.isSelectingUnit = true
		self.isUpgradeMode = true

		-- 보유 유닛 중 랜덤 4개 + 버프 타입 생성
		local upgradeChoices = self:GenerateUpgradeChoices()
		if upgradeChoices == nil or #upgradeChoices == 0 then
			self.isSelectingUnit = false
			self.isUpgradeMode = false
			if self.onSelectionCompleteCallback ~= nil then
				self.onSelectionCompleteCallback()
				self.onSelectionCompleteCallback = nil
			end
			return
		end

		self.currentUpgradeChoices = upgradeChoices

		-- 게임 일시정지
		if _MatrixGameManager ~= nil then
			_MatrixGameManager:PauseGame()
		end

		-- 서버측 일시정지
		if _MatrixService ~= nil then
			_MatrixService:SetGamePausedOnServer(true)
		end

		-- MatrixSelectUI 컨테이너 활성화
		if self.matrixSelectUI ~= nil then
			self.matrixSelectUI.Enable = true
			self.matrixSelectUI.Visible = true
		end

		-- UnitSelectUI 활성화, 증강 패널 비활성화
		if self.unitSelectUI ~= nil then
			self.unitSelectUI.Enable = true
			self.unitSelectUI.Visible = true
		end
		if self.augmentPanel ~= nil then
			self.augmentPanel.Enable = false
		end

		-- CharterView에 강화 선택지 표시
		self:PopulateUpgradeViews(upgradeChoices)

	end

	-- 보유 유닛 중 랜덤 4개 선택 + 50% 확률로 공격력/체력 버프 할당
	method table GenerateUpgradeChoices()
		local user = _UserService.LocalPlayer
		if user == nil or user.UserMatrixManager == nil then
			return {}
		end

		local unitList = user.UserMatrixManager.unitList

		-- 보유 유닛 ID 목록
		local ownedUnitIds = {}
		for unitId, _ in pairs(unitList) do
			table.insert(ownedUnitIds, unitId)
		end

		if #ownedUnitIds == 0 then
			return {}
		end

		-- Fisher-Yates 셔플
		for i = #ownedUnitIds, 2, -1 do
			local j = math.random(1, i)
			ownedUnitIds[i], ownedUnitIds[j] = ownedUnitIds[j], ownedUnitIds[i]
		end

		-- 최대 4개 선택 + 버프 타입 할당
		local choices = {}
		for i = 1, math.min(4, #ownedUnitIds) do
			local unitId = ownedUnitIds[i]
			local buffType = "DAMAGE"
			local buffValue = self.overlapDamageBonus

			-- 50% 확률로 공격력 또는 체력
			if math.random() < 0.5 then
				buffType = "DAMAGE"
				buffValue = self.overlapDamageBonus
			else
				buffType = "HP"
				buffValue = self.overlapHPBonus
			end

			table.insert(choices, {
				unitId = unitId,
				buffType = buffType,
				buffValue = buffValue
			})

		end

		return choices
	end

	-- 강화 선택지를 CharterView에 표시
	method void PopulateUpgradeViews(table upgradeChoices)
		if self.charterViewList == nil then
			return
		end

		local user = _UserService.LocalPlayer
		if user == nil or user.UserMatrixManager == nil then
			return
		end

		local unitPool = user.UserMatrixManager.unitPool
		local children = self.charterViewList.Children
		local index = 1

		for _, child in pairs(children) do
			if child.CharterView ~= nil then
				if index > #upgradeChoices then
					child.CharterView.Entity.Enable = false
				else
					local choice = upgradeChoices[index]
					local unitData = unitPool[choice.unitId]

					if unitData ~= nil then
						child.CharterView:InitUpgrade(unitData, choice.buffType, choice.buffValue)
					else
						child.CharterView.Entity.Enable = false
					end
				end
				index = index + 1
			end
		end
	end

	-- 강화 선택 처리
	@ExecSpace("Client")
	method void SelectUpgradeByIndex(integer index)
		if not self.isSelectingUnit or not self.isUpgradeMode then
			return
		end

		local choice = self.currentUpgradeChoices[index]
		if choice == nil then
			return
		end

		self.isSelectingUnit = false
		self.isUpgradeMode = false

		-- 클라이언트 unitPool 데이터 업데이트
		local user = _UserService.LocalPlayer
		if user ~= nil and user.UserMatrixManager ~= nil then
			local unitData = user.UserMatrixManager.unitPool[choice.unitId]
			if unitData ~= nil then
				if choice.buffType == "DAMAGE" then
					unitData.damage = unitData.damage + choice.buffValue
				elseif choice.buffType == "HP" then
					unitData.hp = unitData.hp + choice.buffValue
				end
			end
		end

		-- 서버에 필드 유닛 버프 적용 (직접 호출)
		self:ApplyUpgradeToUnitServer(choice.unitId, choice.buffType, choice.buffValue)

		-- UI 닫기
		self:CloseUnitSelectionUI()

		-- 남은 선택 처리
		self.remainingSelections = self.remainingSelections - 1

		if self.remainingSelections > 0 then
			-- 다음 선택 (0.5초 딜레이)
			_TimerService:SetTimerOnce(function()
				self:ShowUnitSelectionUI()
			end, 0.5)
		else
			-- 선택 완료 → 콜백 호출
			if self.onSelectionCompleteCallback ~= nil then
				local callback = self.onSelectionCompleteCallback
				self.onSelectionCompleteCallback = nil
				callback()
			end
		end
	end

	@ExecSpace("Server")
	method void ApplyUpgradeToUnitServer(string unitId, string buffType, number buffValue)
		-- 강화 데이터 누적 저장 (스폰 시 적용 위해)
		if self.unitUpgrades[unitId] == nil then
			self.unitUpgrades[unitId] = {damage = 0, hp = 0}
		end
		if buffType == "DAMAGE" then
			self.unitUpgrades[unitId].damage = self.unitUpgrades[unitId].damage + buffValue
		elseif buffType == "HP" then
			self.unitUpgrades[unitId].hp = self.unitUpgrades[unitId].hp + buffValue
		end

		-- 필드 위 해당 유닛에도 즉시 적용
		local gameMapPath = _GameManager:GetGameMapName()
		local myMonsterList = _EntityService:GetEntityByPath(gameMapPath .. "/MyMonsterList")

		if myMonsterList ~= nil then
			for _, child in pairs(myMonsterList.Children) do
				if child.Unit ~= nil and child.Unit.id == unitId and child.Unit.curState ~= "die" then
					child.Unit:GetUnitOverlap(buffType, buffValue)
				end
			end
		end
	end

	-- 스폰 시 저장된 중복 강화를 유닛에 적용
	method void ApplyStoredUpgrades(Entity spawnEntity)
		if spawnEntity == nil or spawnEntity.Unit == nil then
			return
		end

		local unitId = spawnEntity.Unit.id
		local upgrade = self.unitUpgrades[unitId]
		if upgrade == nil then
			return
		end

		if upgrade.damage > 0 then
			spawnEntity.Unit:GetUnitOverlap("DAMAGE", upgrade.damage)
		end
		if upgrade.hp > 0 then
			spawnEntity.Unit:GetUnitOverlap("HP", upgrade.hp)
		end
	end

	-- 메소 income UI 업데이트 (시너지 변경 반영)
	@ExecSpace("Server")
	method void RefreshMesoIncomeUI()
		local mapPath = "/maps/MatrixStage"
		local mesoIncomeEntity = _EntityService:GetEntityByPath(mapPath .. "/ingameIncome")
		if mesoIncomeEntity ~= nil and mesoIncomeEntity.MesoIncome ~= nil then
			mesoIncomeEntity.MesoIncome:RefreshIncomeUI()
		end
	end

end
