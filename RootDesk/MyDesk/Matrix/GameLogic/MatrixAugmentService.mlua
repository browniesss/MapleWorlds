@Logic
script MatrixAugmentService extends Logic

	property table synergyBonusMap = {}

	-- 메소 수입 배율 (증강 효과로 변동)
	property number mesoIncomeMultiplier = 1.0

	-- T.U.R.B.O 모드 활성화 여부
	property boolean isTurboActive = false
	property number preTurboTimeScale = 1.0
	property boolean preTurboIsSpeedUp = false

	-- 멀티플라이어 관련
	property boolean isMultiplierActive = false
	property number multiplierStatRatio = 1.0
	property boolean isCloneSpawn = false

	-- ============================================
	-- 효과 적용
	-- ============================================

	@ExecSpace("Server")
	method void ApplyMatrixEffect(table matrixData)
		local effectType = matrixData.type

		if effectType == "STAT" or effectType == "BUFF" then
			self:ApplyBuffEffect(matrixData)
		elseif effectType == "SYNERGY" then
			self:ApplySynergyEffect(matrixData)
		elseif effectType == "TRIGGER" then
			self:ApplyTriggerEffect(matrixData)
		elseif effectType == "SPECIAL" then
			self:ApplySpecialEffect(matrixData)
		elseif effectType == "MESO" then
			self:ApplyMesoEffect(matrixData)
		elseif effectType == "INFINITE" then
			self:ApplyInfiniteEffect(matrixData)
		end
	end

	@ExecSpace("Server")
	method void ApplyBuffEffect(table matrixData)
		-- 현재 맵의 모든 아군 유닛에게 버프 적용
		local gameMapPath = _GameManager:GetGameMapName()
		local myMonsterList = _EntityService:GetEntityByPath(gameMapPath.."/MyMonsterList")

		if myMonsterList == nil then
			return
		end

		for _, child in ipairs(myMonsterList.Children) do
			if child.Unit ~= nil then
				self:ApplyBuffToUnit(child.Unit, matrixData)
			end
		end
	end

	method void ApplyBuffToUnit(any unit, table matrixData)
		local buffType = self:GetBuffTypeByName(matrixData.effectType)
		if buffType == 0 then
			return
		end

		local buffAmount = matrixData.value

		-- 비율 계산인 경우
		if matrixData.calcType == "PERCENT" then
			buffAmount = self:CalcRatioValue(unit, matrixData.effectType, matrixData.value)
		end

		-- 매트릭스 전용 버프 적용 (서버에서 @Sync 프로퍼티 직접 변경 + 보너스 추적)
		unit:GetMatrix(buffType, buffAmount)
	end

	method number GetBuffTypeByName(string effectType)
		if effectType == "AttackSpeedBuff" then
			return _eBuffType.AttackSpeedBuff
		elseif effectType == "MaxHealthMultiplyBuff" then
			return _eBuffType.MaxHealthMultiplyBuff
		elseif effectType == "AttackDamageBuff" then
			return _eBuffType.AttackDamageBuff
		elseif effectType == "MoveSpeedBuff" then
			return _eBuffType.MoveSpeedBuff
		elseif effectType == "DamageDecreaseBuff" then
			return _eBuffType.DamageDecreaseBuff
		end
		return 0
	end

	method number CalcRatioValue(any unit, string effectType, number ratio)
		if effectType == "AttackDamageBuff" then
			return unit.originDamage * (ratio - 1)
		elseif effectType == "MaxHealthMultiplyBuff" then
			return ratio
		elseif effectType == "AttackSpeedBuff" then
			return unit.originAttackSpeed * (1 - ratio)
		elseif effectType == "MoveSpeedBuff" then
			return unit.originMoveSpeed * (ratio - 1)
		end
		return 0
	end

	@ExecSpace("Server")
	method void ApplySynergyEffect(table matrixData)
		-- 시너지 보너스는 UserMatrixManager.matrixEffects에 저장되어 있고,
		-- GET_SYNERGY_COUNT에서 자동으로 보너스를 계산하므로 별도 처리 불필요

		-- 시너지 보너스 유닛 체크 (시그너스 등)
		local user = _UserService:GetUserEntityByUserId(senderUserId)
		if user ~= nil and user.UserMatrixManager ~= nil then
			user.UserMatrixManager:CheckAndAddSynergyUnits()
		end
	end

	-- 트리거 효과 저장 (Phase 3에서 확장)
	@ExecSpace("Server")
	method void ApplyTriggerEffect(table matrixData)
		-- triggerType: OnAttack, OnHit, OnKill, OnDie, OnStart
		-- 트리거 효과는 activeMatrixEffects에 저장되어 있으므로
		-- 실제 트리거 발동 시 GetTriggerEffects()로 조회하여 처리
	end

	@ExecSpace("Server")
	method void ApplySpecialEffect(table matrixData)
		local effectType = matrixData.effectType

		-- 커스텀 특수 효과 처리 (확장 가능)
		if effectType == "SkillCooldownReduction" then
			-- 스킬 쿨타임 감소 (추후 구현)
		elseif effectType == "TurboMode" then
			self:ApplyTurboMode(matrixData)
		elseif effectType == "Multiplier" then
			self:ApplyMultiplierMode(matrixData)
		end
	end

	-- T.U.R.B.O 모드 적용 (게임 속도 x3 + 아군 공격력/체력 1.5배)
	@ExecSpace("Server")
	method void ApplyTurboMode(table matrixData)
		local speedValue = matrixData.value

		-- 원래 배속 저장 (복원용)
		self.preTurboTimeScale = _TimeScaleManager.timeScale
		self.preTurboIsSpeedUp = _TimeScaleManager.isSpeedUp

		-- 게임 속도 설정
		_TimeScaleManager.timeScale = speedValue
		_TimeScaleManager.isSpeedUp = true
		_TimeScaleManager:ApplyTimeScaleToAllClients(speedValue)

		-- 모든 현재 아군 유닛에 공격력/체력 1.5배 적용
		local gameMapPath = _GameManager:GetGameMapName()
		local myMonsterList = _EntityService:GetEntityByPath(gameMapPath.."/MyMonsterList")

		if myMonsterList ~= nil then
			for _, child in ipairs(myMonsterList.Children) do
				if child.Unit ~= nil then
					self:ApplyTurboBuffToUnit(child.Unit)
				end
			end
		end

		-- 터보 활성화 플래그
		self.isTurboActive = true

		-- 클라이언트에 속도 토글 버튼 비활성화 + TurboEffect 활성화 요청
		self:SetTurboUI(true, speedValue)
	end

	-- T.U.R.B.O 버프를 단일 유닛에 적용 (최종 스탯의 1.5배)
	method void ApplyTurboBuffToUnit(any unit)
		-- 공격력: 현재 최종 damage의 1.5배
		local attackBonus = unit.damage * 0.5
		unit:GetMatrix(_eBuffType.AttackDamageBuff, attackBonus)

		-- 체력: 현재 최종 maxHP의 1.5배 (GetMatrix가 현재 maxHP 기준으로 곱셈)
		unit:GetMatrix(_eBuffType.MaxHealthMultiplyBuff, 1.5)
	end

	-- 멀티플라이어 모드 적용 (소환 시 복제본 추가 생성)
	@ExecSpace("Server")
	method void ApplyMultiplierMode(table matrixData)
		self.isMultiplierActive = true
		self.multiplierStatRatio = matrixData.value
	end

	-- 복제본 스탯 감소 적용
	method void ApplyCloneStatReduction(any unit, number ratio)
		unit.damage = math.floor(unit.damage * ratio)
		unit.originDamage = math.floor(unit.originDamage * ratio)

		local hpRatio = unit.hp / unit.maxHP
		unit.maxHP = math.floor(unit.maxHP * ratio)
		unit.originMaxHP = math.floor(unit.originMaxHP * ratio)
		unit.hp = math.floor(unit.maxHP * hpRatio)
	end

	-- 터보 UI 활성화/비활성화 (버튼 + TurboEffect + UIText)
	@ExecSpace("Client")
	method void SetTurboUI(boolean turboActive, number speedValue)
		-- PlaySpeedButton 처리
		local button = _EntityService:GetEntityByPath("/ui/MatrixUI/IngameUI/IngameInfoUI/PlaySpeedButton")
		if button ~= nil then
			-- x배속 표시용 Root 오브젝트
			local root = button:GetChildByName("Root")
			if root ~= nil then
				root.Enable = turboActive

				-- Root 하위 UIText 엔티티의 TextComponent에 배속 값 표시
				if turboActive then
					local uiText = root:GetChildByName("UIText")
					if uiText ~= nil and uiText.TextComponent ~= nil then
						uiText.TextComponent.Text = tostring(math.floor(speedValue)) .. "x"
					end
				end
			end

			-- 터보 해제 시: 아이콘을 현재 상태에 맞게 복원
			if not turboActive and button.SpeedToggleButton ~= nil then
				if _TimeScaleManager ~= nil then
					button.SpeedToggleButton.localIsSpeedUp = _TimeScaleManager.isSpeedUp
				else
					button.SpeedToggleButton.localIsSpeedUp = false
				end
				button.SpeedToggleButton:UpdateIcon()
			end

			if button.ButtonComponent ~= nil then
				button.ButtonComponent.Enable = not turboActive
			end
		end

		-- TurboEffect 활성화/비활성화
		local turboEffect = _EntityService:GetEntityByPath("/ui/MatrixUI/IngameUI/IngameInfoUI/MatrixEffect/TurboEffect")
		if turboEffect ~= nil then
			turboEffect.Enable = turboActive
			turboEffect.SpriteGUIRendererComponent.PlayRate = 1/speedValue
		end
	end

	@ExecSpace("Server")
	method void ApplyMesoEffect(table matrixData)
		local effectType = matrixData.effectType

		if effectType == "MesoIncomeMultiplier" then
			-- 배율 누적 적용 (예: 기존 1.0 + 0.2 = 1.2)
			if matrixData.calcType == "PERCENT" then
				self.mesoIncomeMultiplier = self.mesoIncomeMultiplier * matrixData.value
			elseif matrixData.calcType == "FLAT" then
				self.mesoIncomeMultiplier = self.mesoIncomeMultiplier + matrixData.value
			end
		end
	end

	-- 무한 모드 전용 증강 효과 적용 (전체 유닛 스탯 고정값 증가)
	@ExecSpace("Server")
	method void ApplyInfiniteEffect(table matrixData)
		local gameMapPath = _GameManager:GetGameMapName()
		local myMonsterList = _EntityService:GetEntityByPath(gameMapPath.."/MyMonsterList")

		if myMonsterList == nil then
			return
		end

		local effectType = matrixData.effectType
		local value = matrixData.value

		for _, child in ipairs(myMonsterList.Children) do
			if child.Unit ~= nil then
				self:ApplyInfiniteBuffToUnit(child.Unit, effectType, value)
			end
		end

	end

	-- 무한 모드 증강을 단일 유닛에 적용
	method void ApplyInfiniteBuffToUnit(any unit, string effectType, number value)
		if effectType == "AttackDamageBuff" then
			-- 공격력 고정 증가
			unit.damage = unit.damage + value
			unit.originDamage = unit.originDamage + value
		elseif effectType == "MaxHealthBuff" then
			-- 최대 체력 고정 증가
			local hpRatio = unit.hp / unit.maxHP
			unit.maxHP = unit.maxHP + value
			unit.originMaxHP = unit.originMaxHP + value
			unit.hp = unit.maxHP * hpRatio  -- HP 비율 유지
		elseif effectType == "AttackSpeedBuff" then
			-- 공격속도 증가 (간격 감소)
			unit.attackSpeed = unit.attackSpeed - value
			unit.originAttackSpeed = unit.originAttackSpeed - value
			-- 최소값 제한
			if unit.attackSpeed < 0.5 then
				unit.attackSpeed = 0.5
			end
			if unit.originAttackSpeed < 0.5 then
				unit.originAttackSpeed = 0.5
			end
		elseif effectType == "MoveSpeedBuff" then
			-- 이동속도 고정 증가
			unit.moveSpeed = unit.moveSpeed + value
			unit.originMoveSpeed = unit.originMoveSpeed + value
		elseif effectType == "AttackRangeBuff" then
			-- 사거리 고정 증가
			unit.attackRange = unit.attackRange + value
		end
	end

	-- ============================================
	-- 스폰 시 버프 적용 (개별 Augment 컴포넌트 대체)
	-- ============================================

	method void ApplySpawnBuffs(Entity spawnEntity, Entity user)
		-- 매트릭스 모드가 아니면 스킵
		if _GameManager.currentGameMode ~= _eGameMode.Matrix then
			return
		end

		if user == nil or user.UserMatrixManager == nil then
			return
		end

		local matrixEffects = user.UserMatrixManager:GetMatrixEffects()
		if matrixEffects == nil or #matrixEffects == 0 then
			return
		end

		local unit = spawnEntity.Unit
		if unit == nil then
			return
		end

		for _, matrix in ipairs(matrixEffects) do
			-- INFINITE 타입은 직접 스탯 적용
			if matrix.type == "INFINITE" then
				self:ApplyInfiniteBuffToUnit(unit, matrix.effectType, matrix.value)
			-- STAT/BUFF 타입은 GetMatrix로 버프 적용
			elseif matrix.type == "STAT" or matrix.type == "BUFF" then
				self:ApplyBuffToUnit(unit, matrix)
			end
		end

		-- T.U.R.B.O 모드 활성화 시 공격력/체력 1.5배 자동 적용
		if self.isTurboActive then
			self:ApplyTurboBuffToUnit(unit)
		end
	end

	-- ============================================
	-- 효과 조회
	-- ============================================

	-- UserMatrixManager에서 증강 효과 목록 가져오기
	method table GetMatrixEffects()
		local user = _UserService.LocalPlayer
		if user ~= nil and user.UserMatrixManager ~= nil then
			return user.UserMatrixManager:GetMatrixEffects()
		end
		return {}
	end

	-- 특정 트리거 타입의 효과 목록 반환
	method table GetTriggerEffects(string triggerType)
		local effects = {}
		local matrixEffects = self:GetMatrixEffects()
		for _, matrix in ipairs(matrixEffects) do
			if matrix.type == "TRIGGER" and matrix.triggerType == triggerType then
				table.insert(effects, matrix)
			end
		end
		return effects
	end

	method table GetActiveEffects()
		return self:GetMatrixEffects()
	end

	method table GetActiveBuffEffects()
		local buffEffects = {}
		local matrixEffects = self:GetMatrixEffects()
		for _, matrix in ipairs(matrixEffects) do
			if matrix.type == "STAT" or matrix.type == "BUFF" then
				table.insert(buffEffects, matrix)
			end
		end
		return buffEffects
	end

	-- ============================================
	-- 트리거 계산 메서드들 (Unit.mlua에서 호출)
	-- ============================================

	-- 공격 시 데미지 계산 (OnAttack)
	method number CalcAttackDamage(Entity attacker, number baseDamage)
		if _GameManager == nil or not (_GameManager.currentGameMode == _eGameMode.Matrix) then
			return baseDamage
		end

		local finalDamage = baseDamage
		local triggerEffects = self:GetTriggerEffects("OnAttack")

		for _, effect in ipairs(triggerEffects) do
			if effect.effectType == "BonusDamage" then
				if effect.calcType == "PERCENT" then
					finalDamage = finalDamage * effect.value
				elseif effect.calcType == "FLAT" then
					finalDamage = finalDamage + effect.value
				end
			end
		end

		return finalDamage
	end

	-- 피격 시 데미지 계산 (OnHit)
	method number CalcOnHitDamage(Entity defender, number incomingDamage)
		if _GameManager == nil or not (_GameManager.currentGameMode == _eGameMode.Matrix) then
			return incomingDamage
		end

		local finalDamage = incomingDamage
		local triggerEffects = self:GetTriggerEffects("OnHit")

		for _, effect in ipairs(triggerEffects) do
			if effect.effectType == "DamageReduction" then
				if effect.calcType == "PERCENT" then
					finalDamage = finalDamage * effect.value
				elseif effect.calcType == "FLAT" then
					finalDamage = finalDamage - effect.value
					if finalDamage < 1 then
						finalDamage = 1
					end
				end
			end
		end

		return finalDamage
	end

	-- 처치 시 효과 (OnKill)
	method void OnKillEffect(Entity killer, Entity victim)
		if _GameManager == nil or not (_GameManager.currentGameMode == _eGameMode.Matrix) then
			return
		end

		if killer.Unit == nil then
			return
		end

		local triggerEffects = self:GetTriggerEffects("OnKill")

		for _, effect in ipairs(triggerEffects) do
			if effect.effectType == "HealOnKill" then
				-- 처치 시 HP 회복
				local healAmount = 0
				if effect.calcType == "PERCENT" then
					healAmount = killer.Unit.maxHP * effect.value
				elseif effect.calcType == "FLAT" then
					healAmount = effect.value
				end
				killer.Unit:OnHeal(killer, healAmount)
			elseif effect.effectType == "GoldOnKill" then
				-- 처치 시 소환 포인트 추가
				local goldAmount = effect.value or 0
				local mapPath = _MatrixGameManager:GetMapPath()
				local mesoWallet = _EntityService:GetEntityByPath(mapPath .. "/userWallet")
				if mesoWallet ~= nil and mesoWallet.MesoWallet ~= nil then
					mesoWallet.MesoWallet:AddMeso(goldAmount)
				end
			elseif effect.effectType == "SpawnOnKill" then
				-- 처치 시 확률적으로 스켈독 소환
				local roll = math.random()
				if roll <= effect.value then
					local pos = victim.TransformComponent.Position
					_MatrixSpawnManager:SpawnSkeletonDog(pos)
				end
			end
		end
	end

	-- 마나 회복 계산 (공격 시 MP 증가량 보너스)
	method number CalcMpRecovery(Entity attacker, number baseMpGain)
		if _GameManager == nil or not (_GameManager.currentGameMode == _eGameMode.Matrix) then
			return baseMpGain
		end

		local finalMpGain = baseMpGain

		-- matrixEffects를 순회하여 마나 회복 증강 찾기
		local matrixEffects = self:GetMatrixEffects()
		for _, matrix in ipairs(matrixEffects) do
			-- TRIGGER 타입이면서 Always 트리거이거나, STAT 타입인 경우
			if (matrix.type == "TRIGGER" and matrix.triggerType == "Always") or matrix.type == "STAT" then
				if matrix.effectType == "MpRecoveryBonus" then
					if matrix.calcType == "PERCENT" then
						finalMpGain = finalMpGain * matrix.value
					elseif matrix.calcType == "FLAT" then
						finalMpGain = finalMpGain + matrix.value
					end
				end
			end
		end

		return finalMpGain
	end

	-- 사망 시 효과 (OnDie) - 아군 유닛 사망 시 주변 적에게 효과 적용
	method void OnDieEffect(Entity deadUnit, Entity killer)
		if _GameManager == nil or not (_GameManager.currentGameMode == _eGameMode.Matrix) then
			return
		end

		local triggerEffects = self:GetTriggerEffects("OnDie")
		if #triggerEffects == 0 then
			return
		end

		-- 사망한 유닛 위치
		local deadPos = deadUnit.TransformComponent.WorldPosition

		-- 매트릭스 모드에서는 MatrixGameManager 경로 사용
		local mapPath = "/maps/MatrixStage"
		if _MatrixGameManager ~= nil then
			mapPath = _MatrixGameManager:GetMapPath()
		end

		-- 적 리스트에서 범위 내 적 탐색
		local enemyList = _EntityService:GetEntityByPath(mapPath .. "/EnemyList")
		if enemyList == nil then
			return
		end


		for _, effect in ipairs(triggerEffects) do
			if effect.effectType == "FreezeOnDie" then
				self:ApplyFreezeOnDie(deadPos, enemyList, effect)
			elseif effect.effectType == "KnockbackOnDie" then
				self:ApplyKnockbackOnDie(deadPos, enemyList, effect)
			elseif effect.effectType == "SpawnOnDie" then
				-- 미니 복제본 2개 소환 (MiniClone은 재귀 방지)
				if deadUnit.Name ~= "MiniClone" then
					local modelID = deadUnit.Unit.id
					local level = deadUnit.Unit.level
					local limitBreak = deadUnit.Unit.limitBreak
					local ratio = effect.value
					_MatrixSpawnManager:SpawnMiniClone(modelID, deadPos, level, limitBreak, ratio, -2)
					_MatrixSpawnManager:SpawnMiniClone(modelID, deadPos, level, limitBreak, ratio, -1)
				end
			end
		end
	end

	-- 등급별 범위 반환
	method number GetOnDieRange(string grade)
		if grade == "LEGENDARY+" then
			return 6
		elseif grade == "LEGENDARY" then
			return 5
		elseif grade == "UNIQUE" then
			return 4
		else
			return 3
		end
	end

	-- 범위 내 적 목록 반환
	method table FindEnemiesInRange(Vector3 pos, Entity enemyList, number range)
		local targets = {}
		for _, entity in ipairs(enemyList.Children) do
			if entity.Unit ~= nil and entity.Unit.curState ~= "die" then
				local targetPos = entity.TransformComponent.WorldPosition
				local distance = math.abs(targetPos.x - pos.x)
				if distance <= range then
					table.insert(targets, entity)
				end
			end
		end
		return targets
	end

	-- 빙결 효과 적용 (아군 사망 시) - 클라이언트에서 호출, 서버로 전달
	method void ApplyFreezeOnDie(Vector3 deadPos, Entity enemyList, table effect)
		local range = self:GetOnDieRange(effect.grade)
		local freezeTime = effect.value
		local targets = self:FindEnemiesInRange(deadPos, enemyList, range)

		-- 서버에서 빙결 적용 (curState가 @Sync 프로퍼티이므로)
		for _, enemy in ipairs(targets) do
			if enemy.Unit ~= nil and enemy.Unit.curState ~= "die" then
				self:ApplyFreezeOnServer(enemy, freezeTime)
			end
		end

	end

	-- 서버에서 빙결 디버프 적용
	@ExecSpace("Server")
	method void ApplyFreezeOnServer(Entity enemy, number freezeTime)
		if enemy == nil or enemy.Unit == nil then
			return
		end
		enemy.Unit:GetDebuff(_eDebuffType.Freeze, 0, freezeTime)
	end

	-- 밀치기 효과 적용 (아군 사망 시) - 스턴은 서버, 이동은 클라이언트
	method void ApplyKnockbackOnDie(Vector3 deadPos, Entity enemyList, table effect)
		local range = self:GetOnDieRange(effect.grade)
		local pushDistance = effect.value
		local targets = self:FindEnemiesInRange(deadPos, enemyList, range)

		-- 밀치기 거리에 비례한 스턴 시간 (거리 1당 0.1초 + 밀치기 시간 0.2초)
		local pushDuration = 0.2
		local stunTime = (pushDistance * 0.1) + pushDuration

		for _, enemy in ipairs(targets) do
			if enemy.Unit ~= nil and enemy.Unit.curState ~= "die" then
				local enemyPos = enemy.TransformComponent.WorldPosition
				local direction = 1
				if enemyPos.x < deadPos.x then
					direction = -1
				end

				-- 서버에서 스턴 적용 (적 유닛이므로 서버에서 처리 필요)
				self:ApplyStunOnServer(enemy, stunTime)

				-- 클라이언트에서 밀치기 이동 처리
				local pushSteps = 10
				local pushInterval = 0.02
				local stepDistance = pushDistance / pushSteps

				for i = 1, pushSteps do
					_TimerService:SetTimerOnce(function()
						if isvalid(enemy) and enemy.Unit.curState ~= "die" then
							local pos = enemy.TransformComponent.WorldPosition
							local ratio = 1 - (i / pushSteps)
							enemy.TransformComponent.WorldPosition = Vector3(pos.x + (stepDistance * ratio * 2 * direction), pos.y, pos.z)
						end
					end, pushInterval * i)
				end
			end
		end

	end

	-- 서버에서 스턴 적용
	@ExecSpace("Server")
	method void ApplyStunOnServer(Entity enemy, number stunTime)
		if enemy == nil or enemy.Unit == nil then
			return
		end
		enemy.Unit:GetDebuff(_eDebuffType.Stun, 0, stunTime)
	end

	-- ============================================
	-- 상태 초기화
	-- ============================================

	@ExecSpace("Server")
	method void ClearAllEffects()
		-- 시너지 보너스는 UserMatrixManager.matrixEffects 초기화 시 자동으로 제거됨
		-- (GET_SYNERGY_COUNT에서 matrixEffects 기반으로 보너스 계산)

		-- 상태 초기화
		self.synergyBonusMap = {}
		self.mesoIncomeMultiplier = 1.0

		-- T.U.R.B.O 모드 초기화 (항상 리셋하여 상태 불일치 방지)
		-- SaveAndReset이 터보 상태를 저장하지 않도록 원래 배속으로 복원
		if _TimeScaleManager ~= nil then
			_TimeScaleManager.lastTimeScale = self.preTurboTimeScale
			_TimeScaleManager.lastIsSpeedUp = self.preTurboIsSpeedUp
		end
		self.isTurboActive = false
		self.preTurboTimeScale = 1.0
		self.preTurboIsSpeedUp = false

		self:SetTurboUI(false, 0)

		-- 멀티플라이어 초기화
		self.isMultiplierActive = false
		self.multiplierStatRatio = 1.0
		self.isCloneSpawn = false

		-- MatrixService 상태 초기화
		if _MatrixService ~= nil then
			_MatrixService:ClearSelectState()
		end
	end

end
